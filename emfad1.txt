
====================================================================================================
ANDROID PROJEKT KONSOLIDIERUNG
====================================================================================================
Projektpfad: /Users/nancy/Downloads/emfad1-main
Anzahl Dateien: 84
Generiert am: 2025-06-14 04:47:38
====================================================================================================

INHALTSVERZEICHNIS:
  1. Models/Measurement.cs
  2. Models/MeasurementData.kt
  3. README.md
  4. Services/BluetoothService.cs
  5. Services/BluetoothService.kt
  6. Services/DataService.cs
  7. Services/GPSService.cs
  8. Services/LocationService.kt
  9. Services/MeasurementService.cs
 10. Services/MeasurementService.kt
 11. ViewModels/BluetoothViewModel.cs
 12. ViewModels/GPSViewModel.cs
 13. ViewModels/MainViewModel.kt
 14. ViewModels/MeasurementViewModel.cs
 15. ViewModels/VisualizationViewModel.cs
 16. Views/BluetoothPage.xaml
 17. Views/GPSPage.xaml
 18. Views/MainScreen.kt
 19. Views/MeasurementPage.xaml
 20. Views/VisualizationPage.xaml
 21. app/build.gradle
 22. app/proguard-rules.pro
 23. app/src/main/AndroidManifest.xml
 24. app/src/main/java/com/emfad/app/MainActivity.kt
 25. app/src/main/java/com/emfad/app/bluetooth/BluetoothManager.kt
 26. app/src/main/java/com/emfad/app/bluetooth/EMFADDevice.kt
 27. app/src/main/java/com/emfad/app/data/MeasurementDatabase.kt
 28. app/src/main/java/com/emfad/app/models/AnalysisThresholds.kt
 29. app/src/main/java/com/emfad/app/models/AutomaticCalibration.kt
 30. app/src/main/java/com/emfad/app/models/ClusterAnalyzer.kt
 31. app/src/main/java/com/emfad/app/models/CrystalDetector.kt
 32. app/src/main/java/com/emfad/app/models/EMFADDevice.kt
 33. app/src/main/java/com/emfad/app/models/EMFADMeasurement.kt
 34. app/src/main/java/com/emfad/app/models/InclusionDetector.kt
 35. app/src/main/java/com/emfad/app/models/MaterialAnalysis.kt
 36. app/src/main/java/com/emfad/app/models/MaterialAnalyzer.kt
 37. app/src/main/java/com/emfad/app/models/MaterialCalibration.kt
 38. app/src/main/java/com/emfad/app/models/MaterialClassifier.kt
 39. app/src/main/java/com/emfad/app/models/MaterialDatabase.kt
 40. app/src/main/java/com/emfad/app/models/MaterialPhysicsAnalyzer.kt
 41. app/src/main/java/com/emfad/app/models/MaterialProperties.kt
 42. app/src/main/java/com/emfad/app/models/MeasurementMode.kt
 43. app/src/main/java/com/emfad/app/models/MeasurementSession.kt
 44. app/src/main/java/com/emfad/app/models/MetalAnalyzer.kt
 45. app/src/main/java/com/emfad/app/navigation/AppNavigation.kt
 46. app/src/main/java/com/emfad/app/services/BluetoothService.kt
 47. app/src/main/java/com/emfad/app/services/DataService.kt
 48. app/src/main/java/com/emfad/app/services/MeasurementService.kt
 49. app/src/main/java/com/emfad/app/ui/MainScreen.kt
 50. app/src/main/java/com/emfad/app/ui/SettingsScreen.kt
 51. app/src/main/java/com/emfad/app/ui/theme/Theme.kt
 52. app/src/main/java/com/emfad/app/ui/theme/Type.kt
 53. app/src/main/java/com/emfad/app/viewmodels/BluetoothViewModel.kt
 54. app/src/main/java/com/emfad/app/viewmodels/MainViewModel.kt
 55. app/src/main/java/com/emfad/app/viewmodels/MeasurementViewModel.kt
 56. app/src/main/java/com/emfad/app/viewmodels/SettingsViewModel.kt
 57. app/src/main/java/com/emfad/app/views/BluetoothPage.kt
 58. app/src/main/java/com/emfad/app/views/MainView.kt
 59. app/src/main/java/com/emfad/app/views/Material3DVisualization.kt
 60. app/src/main/java/com/emfad/app/views/MaterialAnalysisCard.kt
 61. app/src/main/java/com/emfad/app/views/MaterialCalibrationView.kt
 62. app/src/main/java/com/emfad/app/views/MaterialPhysicsAnalysisCard.kt
 63. app/src/main/java/com/emfad/app/views/MaterialThresholdSettings.kt
 64. app/src/main/java/com/emfad/app/views/MaterialTrendChart.kt
 65. app/src/main/java/com/emfad/app/views/MeasurementPage.kt
 66. app/src/main/java/com/emfad/app/views/VisualizationPage.kt
 67. app/src/main/res/drawable/ic_launcher_foreground.xml
 68. app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
 69. app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
 70. app/src/main/res/values-v27/themes.xml
 71. app/src/main/res/values/colors.xml
 72. app/src/main/res/values/dimens.xml
 73. app/src/main/res/values/ic_launcher_background.xml
 74. app/src/main/res/values/strings.xml
 75. app/src/main/res/values/themes.xml
 76. app/src/main/res/xml/backup_rules.xml
 77. app/src/main/res/xml/data_extraction_rules.xml
 78. build.gradle
 79. codemagic.yaml
 80. gradle.properties
 81. gradle/wrapper/gradle-wrapper.properties
 82. gradlew.bat
 83. local.properties
 84. settings.gradle

====================================================================================================
DATEIINHALTE:
====================================================================================================

================================================================================
# DATEI: Models/Measurement.cs
# TYP: .cs
================================================================================
// Measurement.cs Model Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Models/MeasurementData.kt
# TYP: .kt
================================================================================
package com.emfad.app.Models

data class MeasurementData(
    val id: String,
    val timestamp: Long,
    val frequency: Double,
    val mode: MeasurementMode,
    val orientation: MeasurementOrientation,
    val value: Double,
    val latitude: Double?,
    val longitude: Double?
)

enum class MeasurementMode {
    A, B, A_B, B_A
}

enum class MeasurementOrientation {
    HORIZONTAL, VERTICAL
}

data class MeasurementProfile(
    val id: String,
    val name: String,
    val measurements: List<MeasurementData>,
    val profileLength: Double,
    val distance: Double
)

data class MeasurementSession(
    val id: String,
    val name: String,
    val profiles: List<MeasurementProfile>,
    val startTime: Long,
    val endTime: Long?,
    val settings: MeasurementSettings
)

data class MeasurementSettings(
    val frequency: Double,
    val mode: MeasurementMode,
    val orientation: MeasurementOrientation,
    val autoInterval: Double?,
    val filterLevel: Int,
    val gain: Double,
    val offset: Double
) 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: README.md
# TYP: .md
================================================================================
# EMFAD App

## üì± √úberblick
Die EMFAD App ist eine fortschrittliche Anwendung f√ºr die Analyse und Visualisierung von elektromagnetischen Messungen. Sie unterst√ºtzt verschiedene Messmodi und bietet umfangreiche Analysefunktionen.

## üî¨ Messmodi

### 1. B-A Vertikal
- **Beschreibung**: Vertikale Messung mit B-A-Konfiguration
- **Anwendung**: Tiefenmessung, vertikale Strukturen
- **Kalibrierung**: Automatische Kalibrierung f√ºr vertikale Messungen

### 2. A-B Horizontal
- **Beschreibung**: Horizontale Messung mit A-B-Konfiguration
- **Anwendung**: Horizontale Strukturen, Fl√§chenmessung
- **Kalibrierung**: Automatische Kalibrierung f√ºr horizontale Messungen

### 3. Antenne A
- **Beschreibung**: Einzelantennen-Messung
- **Anwendung**: Schnelle Vorortmessung, grobe Orientierung
- **Kalibrierung**: Vereinfachte Kalibrierung f√ºr Einzelantennen

### 4. Tiefe Pro
- **Beschreibung**: Professionelle Tiefenbestimmung
- **Anwendung**: Pr√§zise Tiefenmessung, Schichtanalyse
- **Kalibrierung**: Hz/Hx-Messmethode mit EMTOMO LDA Software

## üîç Materialanalyse

### üíé Kristalline Materialien & Edelsteine

#### Kristalline Nichtleiter
Diese Materialien sind nicht leitf√§hig, erzeugen jedoch messbare Anomalien durch:
- Dichtekontrast
- Kristallstruktur (Anisotropie)
- Resonanzph√§nomene in elektromagnetischen Feldern

| Material       | Dichte (g/cm¬≥) | Leitf√§higkeit (S/m) | Permittivit√§t (Œµr) | Typische Umgebung           |
| -------------- | -------------- | ------------------- | ------------------ | --------------------------- |
| Rubin (Korund) | 3.9‚Äì4.1        | < 10‚Åª¬π‚Å∞             | 9.3‚Äì10             | Pegmatite, Quarzg√§nge       |
| Smaragd        | 2.7‚Äì2.8        | < 10‚Åª¬π‚Å∞             | 6‚Äì8                | Beryllhaltige Adern         |
| Diamant        | 3.5‚Äì3.6        | < 10‚Åª¬π¬≥             | 5.5‚Äì7.0            | Kimberlite, Vulkanr√∂hren    |
| Turmalin       | 3.0‚Äì3.3        | < 10‚Åª‚Åπ              | 12‚Äì15              | Quarz-Pegmatite             |
| Quarz          | 2.6‚Äì2.7        | ‚âà 0                 | 4‚Äì5                | Kristalline Gesteine, G√§nge |

#### Erkennungsansatz
- **Form**: Kompakt, oval/rund, hochsymmetrisch
- **Tiefe**: H√§ufig > 1 m
- **Leitf√§higkeit**: ‚âà 0 S/m
- **Begleitmaterialien**: Pyrit, Quarz, Feldspat
- **Signalverhalten**: Schwache, aber scharf abgegrenzte Impedanz√§nderung

### Nat√ºrliche Adern vs. K√ºnstliche Strukturen

#### Nat√ºrliche Adern
- **Charakteristika**:
  - Hohe Leitf√§higkeit (> 10‚Å¥ S/m)
  - Langgestreckt (Aspektverh√§ltnis > 10)
  - Unsymmetrisch (Symmetrie < 0.3)
  - Tief (> 1.5m)
  - Typische Formen: Ader, Spalt
- **Erkennbare Adern**:
  - Goldader
  - Silberader
  - Kupferader
  - Quarzader
  - Pyritader
  - Magnetitader

#### K√ºnstliche Strukturen
- **Charakteristika**:
  - Extrem niedrige oder hohe Leitf√§higkeit
  - Kompakt (Aspektverh√§ltnis < 3)
  - Symmetrisch (Symmetrie > 0.7)
  - Flacher (< 10m)
  - Typische Formen: Hohlraum, Schicht
- **Erkennbare Strukturen**:
  - Tunnel
  - Kammer
  - Brunnen
  - Fundament
  - Mauer
  - Drainage

### Vergleichstabelle: Echte Ader vs. Gegrabener Schacht

| Kriterium            | Nat√ºrliche Ader             | Menschengemachte Struktur         |
| -------------------- | --------------------------- | --------------------------------- |
| Leitf√§higkeitsprofil | Kontinuierlich mit Gradient | Sprunghaft, evtl. scharfe Grenze  |
| Form                 | Unregelm√§√üig, langgezogen   | Rechteckig, symmetrisch           |
| Tiefe                | Tiefer (>1.5‚ÄØm)             | H√§ufig flacher oder schichtweise  |
| Symmetrie            | Gering (<0.3)               | Hoch (>0.7)                       |
| Magnetfeldgradient   | Unruhig, gestreckt          | Klar begrenzt, gleichm√§√üig        |
| Schichtung           | Nat√ºrlich mit √úberg√§ngen    | Schichtst√∂rung, oft Hohlraum oben |

### Erkennungskriterien

#### 1. Geometrische Eigenschaften
- **Aspektverh√§ltnis**:
  - Nat√ºrlich: > 10 (langgestreckt)
  - K√ºnstlich: < 3 (kompakt)
- **Symmetrie**:
  - Nat√ºrlich: < 0.3 (unsymmetrisch)
  - K√ºnstlich: > 0.7 (symmetrisch)

#### 2. Physikalische Eigenschaften
- **Leitf√§higkeit**:
  - Nat√ºrlich: > 10‚Å¥ S/m
  - K√ºnstlich: < 10‚Åª‚Åπ S/m oder > 10‚Å∂ S/m
- **Permittivit√§t**:
  - Nat√ºrlich: Variabel, typisch 1-10
  - K√ºnstlich: Extrem (Luft ‚âà 1, Metall ‚âà 1)
- **Permeabilit√§t**:
  - Nat√ºrlich: Nahe 1
  - K√ºnstlich: Variabel

#### 3. Magnetfeld-Gradienten
- **Nat√ºrlich**:
  - Verzerrt, unsymmetrisch
  - Schwache St√∂rungen
- **K√ºnstlich**:
  - Symmetrisch
  - Klare Abgrenzungen

#### 4. Tiefe und Form
- **Nat√ºrlich**:
  - Tief > 1.5m
  - Unregelm√§√üige Form
- **K√ºnstlich**:
  - Flach < 10m
  - Regelm√§√üige Form

### Zuverl√§ssigkeitsberechnung

#### Zuverl√§ssigkeits-Skala
- **Score 0-1**: Gewichtete Summe aller Kriterien
- **Klassifikation**:
  - > 0.75: Hohe Wahrscheinlichkeit (üü¢)
  - 0.5-0.75: Mittlere Wahrscheinlichkeit (üü°)
  - < 0.5: Geringe Wahrscheinlichkeit (üî¥)

#### F√ºr Adern
1. Leitf√§higkeit (20%)
2. Aspektverh√§ltnis (20%)
3. Symmetrie (20%)
4. Tiefe (20%)
5. Anomalieform (20%)

#### F√ºr Strukturen
1. Leitf√§higkeit (20%)
2. Aspektverh√§ltnis (20%)
3. Symmetrie (20%)
4. Tiefe (20%)
5. Anomalieform (20%)

### Schichtanalyse

#### Typisches Schichtprofil
```plaintext
1. Humus/Erde (0‚Äì20 cm)
2. Lehm (20‚Äì70 cm)
3. Ton (70‚Äì150 cm)
4. Anomalie (ab 150 cm, Tiefe: 180 cm)
   ‚Üí Typ: Hohlraum mit leitf√§higem Objekt
   ‚Üí Form: Rechteck
```

#### Schichtparameter
- Material
- Tiefe
- Dicke
- Anomalieposition
- √úbergangstyp

## üõ†Ô∏è Technische Implementierung

### Architektur
Die App folgt der **MVVM (Model-View-ViewModel)** Architektur, einem Architekturmuster, das die Entwicklung von robusten und wartbaren Anwendungen auf Android erleichtert. MVVM f√∂rdert die Trennung von Belangen:

- **Model**: Repr√§sentiert die Daten und die Gesch√§ftslogik. In dieser App beinhalten die Models die Datenstrukturen f√ºr Messungen, Profile, Sitzungen und Einstellungen sowie Logik f√ºr Datenverarbeitung.
- **View**: Die Benutzeroberfl√§che (UI). In dieser App wird die UI mit **Jetpack Compose** erstellt. Die Views sind passiv und zeigen nur die Daten an, die ihnen vom ViewModel bereitgestellt werden, und leiten Benutzerinteraktionen an das ViewModel weiter.
- **ViewModel**: H√§lt UI-Zustandsdaten bereit und f√ºhrt Logik aus, die durch Benutzerinteraktionen oder andere Ereignisse ausgel√∂st wird. Das ViewModel interagiert mit den Models und Services, um Daten abzurufen oder zu verarbeiten, und stellt die aufbereiteten Daten f√ºr die Views bereit.

Zus√§tzlich zu den Kern-MVVM-Komponenten verwendet die App **Services** zur Kapselung spezifischer Funktionalit√§ten, die √ºber die reine UI-Logik hinausgehen und oft Hintergrundoperationen oder die Interaktion mit dem Android-System beinhalten.

### Hauptkomponenten

1.  **Models (`com.emfad.app.Models.*`)**: Datentypen (z.B. `MeasurementData`, `MeasurementSession`, `MeasurementSettings`) und zugeh√∂rige Logik.
2.  **Services (`com.emfad.app.Services.*`)**:
    -   `BluetoothService`: Verwaltet die Bluetooth (BLE) Verbindung und den Datenaustausch mit dem EMFAD-Ger√§t.
    -   `LocationService`: Stellt GPS-Standortdaten bereit.
    -   `MeasurementService`: Verwaltet den Lebenszyklus von Messsitzungen und -profilen, f√ºgt Messdaten hinzu und f√ºhrt Datenverarbeitungsfunktionen (Filterung, Statistik) aus.
3.  **ViewModels (`com.emfad.app.ViewModels.*`)**:
    -   `MainViewModel`: Das zentrale ViewModel, das den Zustand der Haupt-UI verwaltet, Benutzerinteraktionen verarbeitet und mit den Services interagiert.
4.  **Views (`com.emfad.app.Views.*`)**: Jetpack Compose Composable Functions, die die Benutzeroberfl√§che darstellen (z.B. `MainScreen`, `SettingsDialog`). Sie beobachten die Zustandsdaten des ViewModels und aktualisieren sich entsprechend.

Diese Struktur gew√§hrleistet eine klare Trennung der Zust√§ndigkeiten und erleichtert die Testbarkeit, Wartung und Erweiterung der App.

### Physikalische Modelle
- Komplexe Impedanz
- Magnetfeld-Gradienten
- Schichtanalyse
- Anomalieerkennung

## üìä Benutzeroberfl√§che

### Hauptansicht
- Messung
- Kalibrierung
- Materialanalyse
- 3D-Visualisierung

### Analyseansicht
- Materialtyp
- Tiefe
- Gr√∂√üe
- Zuverl√§ssigkeit
- Schichtanalyse
- Ader/Struktur-Erkennung

## üîÑ Kalibrierung

### Automatische Kalibrierung
- B-A Vertikal
- A-B Horizontal
- Antenne A
- Tiefe Pro

### Manuelle Kalibrierung
- Kalibrierungspunkte hinzuf√ºgen
- Kalibrierungsfaktoren anpassen
- Qualit√§t √ºberwachen

## üìà Messung

### Durchf√ºhrung
1. Messmodus w√§hlen
2. Kalibrierung durchf√ºhren
3. Messung starten
4. Ergebnisse analysieren

### Analyse
- Materialerkennung
- Tiefenbestimmung
- Schichtanalyse
- Ader/Struktur-Erkennung

## üöÄ Entwicklung

### Abh√§ngigkeiten
- Kotlin 1.8.0
- Jetpack Compose 1.4.0
- Material 3
- Kotlin Coroutines
- Kotlin Flow

### Projektstruktur
```
app/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îú‚îÄ‚îÄ MeasurementMode.kt
‚îÇ   ‚îú‚îÄ‚îÄ MaterialProperties.kt
‚îÇ   ‚îî‚îÄ‚îÄ MaterialPhysicsAnalyzer.kt
‚îú‚îÄ‚îÄ views/
‚îÇ   ‚îú‚îÄ‚îÄ MainView.kt
‚îÇ   ‚îî‚îÄ‚îÄ MaterialCalibrationView.kt
‚îî‚îÄ‚îÄ viewmodels/
    ‚îî‚îÄ‚îÄ MainViewModel.kt
```

## üîú Geplante Funktionen
1. Persistente Speicherung von Kalibrierungsdaten
2. Export/Import von Kalibrierungsprofilen
3. Erweiterte 3D-Visualisierung
4. KI-gest√ºtzte Materialerkennung
5. Verbesserte Ader/Struktur-Erkennung
6. Integration mit GPS-Daten
7. Offline-Modus
8. Mehrsprachige Unterst√ºtzung

## üì± Hardware-Spezifikationen

### EMFAD UG DS WL Ger√§t
| Merkmal            | Wert                  |
| ------------------ | --------------------- |
| Frequenzbereich    | 100 Hz ‚Äì 20 kHz       |
| Antennentyp        | Ferrit, Koaxial       |
| Datenschnittstelle | BLE / USB             |
| Abtastrate         | 200 Samples/s         |
| Stromversorgung    | 3.7V Li-Ion Akku      |
| Software           | EMTOMO LDA, EMFAD App |

## üìö Beispiel-Erkennungsf√§lle

### Goldader vs. Tunnel
```plaintext
Messung:
- Position: 48.1234¬∞N, 11.5678¬∞E
- Tiefe: 2.5m
- Leitf√§higkeit: 4.1e7 S/m
- Form: L√§nglich, unsymmetrisch
- Aspektverh√§ltnis: 15.3

Analyse:
- Typ: Nat√ºrliche Goldader
- Zuverl√§ssigkeit: 0.92 (üü¢)
- Begleitmaterialien: Quarz, Pyrit
- Schichtung: Nat√ºrlich mit √úberg√§ngen
```

### Smaragd in Quarzader
```plaintext
Messung:
- Position: 48.2345¬∞N, 11.6789¬∞E
- Tiefe: 1.8m
- Leitf√§higkeit: < 10‚Åª¬π‚Å∞ S/m
- Dichte: 2.75 g/cm¬≥
- Permittivit√§t: 7.2

Analyse:
- Typ: Smaragd in Quarzader
- Zuverl√§ssigkeit: 0.85 (üü¢)
- Begleitmaterialien: Quarz, Beryll
- Kristallstruktur: Monoklin
```

## üî¨ Physikalische Modelle & Algorithmen

### 1. Kristall-Erkennungsmodus (Low-Signal-Filtering)

#### Ziel
Erkennung schwacher Impedanzanomalien typischer kristalliner Materialien (z.B. Rubin, Quarz, Smaragd).

#### Physikalisches Modell
Kristalle sind **nichtleitend**, erzeugen aber durch ihre **geordnete Struktur** eine messbare √Ñnderung der **lokalen Permittivit√§t** und des **elektrischen Feldgradienten**.

#### Mathematischer Ansatz

##### Komplexe Permittivit√§t:
$$
\varepsilon^* = \varepsilon' - j \cdot \varepsilon''
$$
- $\varepsilon'$: reelle Permittivit√§t (Feldspeicherung)
- $\varepsilon''$: Verlustanteil (Verlustfaktor)

##### Detektion durch Impedanz√§nderung:
$$
\Delta Z(f) = Z_0 \cdot \left( \sqrt{\frac{\mu \cdot \varepsilon^*_{\text{Lokal}}}{\mu_0 \cdot \varepsilon_0}} - 1 \right)
$$

##### Signalfilterung:
- Adaptive Schwellenwertfunktion:
$$
\Delta Z_{\text{min}} = \alpha \cdot \sigma_{\text{Umgebung}}, \quad \alpha \in [1.5, 2.5]
$$
- Medianfilter oder Butterworth-Filter 2. Ordnung

### 2. Differenzanalyse mehrerer Messpunkte (Clustervergleich)

#### Ziel
Vergleich mehrerer Messpunkte zur Erkennung von **r√§umlicher Konsistenz** und **Clusterbildung**.

#### Mathematischer Ansatz

##### Feature-Vektor je Punkt:
$$
\mathbf{x}_i = \begin{bmatrix}
Z_i, \ \sigma_i, \ \varepsilon_i, \ \mu_i, \ d_i
\end{bmatrix}
$$

##### Distanzmatrix:
$$
D_{ij} = \| \mathbf{x}_i - \mathbf{x}_j \|
$$

##### Clustering:
$$
\text{Cluster:} \quad \mathcal{C} = \left\{ \mathbf{x}_i \mid D_{ij} < \epsilon \right\}
$$

##### Anomalie:
$$
\text{Outlier} \iff D_{ij} > \mu_D + 2\sigma_D
$$

### 3. Einschluss-Erkennung (Objekt im Hohlraum)

#### Ziel
Erkennung eines **dichten Objekts** innerhalb eines **nichtleitenden Hohlraums**.

#### Physikalisches Modell

##### Mehrschicht-Modell:
- Au√üenschicht (Luft):
  - $\varepsilon_r \approx 1$
  - $\sigma \approx 0$
- Einschluss (Metall/Kristall):
  - $\varepsilon_r \gg 1$, $\sigma > 0$

##### Reflexions-/Transmissionseffekte:
$$
Z_{\text{eff}} = \frac{Z_1 + jZ_2 \cdot \tan(k_2 d)}{1 + j \frac{Z_2}{Z_1} \cdot \tan(k_2 d)}
$$

##### Einschlussbedingung:
$$
\Delta Z = \text{lokales Maximum bei gleichzeitiger Dip-Zone au√üen}
$$

### 4. Unterscheidung Edelmetall vs. Legierung

#### Ziel
Erkennen von echten Edelmetallen anhand ihres elektromagnetischen Verhaltens.

#### Physikalisches Modell

##### Frequenz-Scan:
$$
Z(f) = R(f) + jX(f) \propto \sqrt{\frac{\mu \cdot \omega}{2 \cdot \sigma}}
$$

##### Skin-Effekt-Tiefe:
$$
\delta = \sqrt{\frac{2}{\mu \cdot \sigma \cdot \omega}}
$$

- **Gold**: $\sigma \approx 4.1 \times 10^7 \,\text{S/m}$
- **Bronze**: $\sigma \approx (1 - 2) \times 10^6 \,\text{S/m}$

##### Analyse:
$$
Z(f)_{\text{Gold}} < Z(f)_{\text{Bronze}} \quad \text{bei steigender Frequenz}
$$

### Zusammenfassung der Methoden

| Funktion                 | Modell              | Hauptformel / Kriterium                               |
| ------------------------ | ------------------- | ----------------------------------------------------- |
| Kristall-Erkennung       | $\varepsilon^*$, ‚àÜZ | $\Delta Z \propto \sqrt{\varepsilon^*}$               |
| Clustervergleich         | $\|x_i - x_j\|$     | $D_{ij} > \mu + 2\sigma \Rightarrow \text{Outlier}$   |
| Einschluss im Hohlraum   | Mehrschicht-Modell  | $Z_{\text{eff}} = f(Z_1, Z_2, k_2, d)$                |
| Edelmetall vs. Legierung | Skin-Effekt         | $\delta = \sqrt{2 / (\mu \cdot \sigma \cdot \omega)}$ |

## üöÄ Quickstart f√ºr Entwickler

### Voraussetzungen
- Android Studio (aktuelle Version empfohlen)
- Android SDK (mind. API 24)
- Kotlin 1.8+
- Internetzugang f√ºr Abh√§ngigkeits-Download

### Projekt aufsetzen & starten
1. Repository klonen:
   ```bash
   git clone https://github.com/emfad/EMFAD_App_Top.git
   cd EMFAD_App_Top
   ```
2. In Android Studio √∂ffnen: `Datei > √ñffnen... > Verzeichnis ausw√§hlen`
3. Gradle-Sync abwarten (Abh√§ngigkeiten werden automatisch geladen)
4. App auf ein Android-Ger√§t (API 24+) oder Emulator installieren und starten

### Wichtige Hinweise
- **Bluetooth**: Die App ben√∂tigt Bluetooth-Berechtigungen (Pairing, Scannen, Verbindung). Diese werden beim ersten Start abgefragt.
- **Standort**: F√ºr Bluetooth-Scanning ab Android 12 ist Standortfreigabe erforderlich.
- **Speicher**: F√ºr das Speichern/Exportieren von Messdaten werden Speicherrechte ben√∂tigt.
- **Ger√§tekopplung**: Das EMFAD-Ger√§t muss vor der Messung per Bluetooth gekoppelt werden (Einstellungen > Bluetooth).

## üóÇÔ∏è Datenstruktur (Beispiel)

### MeasurementData (JSON)
```json
{
  "id": "b1a2c3d4-5678-1234-9abc-def012345678",
  "timestamp": 1712345678901,
  "frequency": 70.0,
  "mode": "A_B",
  "orientation": "HORIZONTAL",
  "value": 0.123,
  "latitude": 48.123456,
  "longitude": 11.654321
}
```

## üõ†Ô∏è Erweiterung & Entwicklung

### Neue Messmodi hinzuf√ºgen
- `MeasurementMode`-Enum in `Models/MeasurementData.kt` erweitern
- Logik im `MeasurementService` und ggf. im ViewModel anpassen

### Neue Auswertungen/Visualisierungen
- Neue Analysefunktionen im `MeasurementService` implementieren
- UI-Komponenten in `Views/` erg√§nzen (z.B. neue Diagramme)

### Export/Import
- Export als CSV/JSON kann √ºber Kotlin-Serialization oder Gson erfolgen
- Import analog, z.B. f√ºr Kalibrierungsprofile

## üÜò Kontakt & Support
- **Entwickler:** EMFAD Geophysikalische Umwelttechnik
- **E-Mail:** info@emfad.de
- **Web:** https://www.emfad.de
- **Support:** Bitte Fehlerberichte und Featurew√ºnsche per E-Mail oder GitHub-Issue melden 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/BluetoothService.cs
# TYP: .cs
================================================================================
// BluetoothService.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/BluetoothService.kt
# TYP: .kt
================================================================================
package com.emfad.app.Services

import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothGatt
import android.bluetooth.BluetoothGattCallback
import android.bluetooth.BluetoothGattCharacteristic
import android.bluetooth.BluetoothProfile
import android.content.Context
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import java.util.UUID

class BluetoothService(private val context: Context) {
    private val bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()
    private var bluetoothGatt: BluetoothGatt? = null
    
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.Disconnected)
    val connectionState: StateFlow<ConnectionState> = _connectionState
    
    private val _measurementData = MutableStateFlow<ByteArray?>(null)
    val measurementData: StateFlow<ByteArray?> = _measurementData

    private val EMFAD_SERVICE_UUID = UUID.fromString("0000FFE0-0000-1000-8000-00805F9B34FB")
    private val EMFAD_CHARACTERISTIC_UUID = UUID.fromString("0000FFE1-0000-1000-8000-00805F9B34FB")

    private val gattCallback = object : BluetoothGattCallback() {
        override fun onConnectionStateChange(gatt: BluetoothGatt?, status: Int, newState: Int) {
            when (newState) {
                BluetoothProfile.STATE_CONNECTED -> {
                    _connectionState.value = ConnectionState.Connected
                    gatt?.discoverServices()
                }
                BluetoothProfile.STATE_DISCONNECTED -> {
                    _connectionState.value = ConnectionState.Disconnected
                }
            }
        }

        override fun onServicesDiscovered(gatt: BluetoothGatt?, status: Int) {
            if (status == BluetoothGatt.GATT_SUCCESS) {
                val characteristic = gatt?.getService(EMFAD_SERVICE_UUID)
                    ?.getCharacteristic(EMFAD_CHARACTERISTIC_UUID)
                
                characteristic?.let {
                    gatt?.setCharacteristicNotification(it, true)
                }
            }
        }

        override fun onCharacteristicChanged(
            gatt: BluetoothGatt?,
            characteristic: BluetoothGattCharacteristic?
        ) {
            characteristic?.value?.let { value ->
                _measurementData.value = value
            }
        }
    }

    fun connect(device: BluetoothDevice) {
        bluetoothGatt = device.connectGatt(context, false, gattCallback)
    }

    fun disconnect() {
        bluetoothGatt?.disconnect()
        bluetoothGatt = null
    }

    fun sendCommand(command: ByteArray) {
        val characteristic = bluetoothGatt?.getService(EMFAD_SERVICE_UUID)
            ?.getCharacteristic(EMFAD_CHARACTERISTIC_UUID)
        
        characteristic?.let {
            it.value = command
            bluetoothGatt?.writeCharacteristic(it)
        }
    }

    sealed class ConnectionState {
        object Connected : ConnectionState()
        object Disconnected : ConnectionState()
        data class Error(val message: String) : ConnectionState()
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/DataService.cs
# TYP: .cs
================================================================================
// DataService.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/GPSService.cs
# TYP: .cs
================================================================================
// GPSService.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/LocationService.kt
# TYP: .kt
================================================================================
package com.emfad.app.Services

import android.annotation.SuppressLint
import android.content.Context
import android.location.Location
import com.google.android.gms.location.FusedLocationProviderClient
import com.google.android.gms.location.LocationServices
import com.google.android.gms.location.Priority
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.tasks.await

class LocationService(private val context: Context) {
    private val fusedLocationClient: FusedLocationProviderClient = 
        LocationServices.getFusedLocationProviderClient(context)
    
    private val _location = MutableStateFlow<Location?>(null)
    val location: StateFlow<Location?> = _location

    @SuppressLint("MissingPermission")
    suspend fun startLocationUpdates() {
        try {
            val locationRequest = com.google.android.gms.location.LocationRequest.Builder(
                Priority.PRIORITY_HIGH_ACCURACY,
                1000 // Update interval in milliseconds
            ).build()

            fusedLocationClient.requestLocationUpdates(
                locationRequest,
                object : com.google.android.gms.location.LocationCallback() {
                    override fun onLocationResult(locationResult: com.google.android.gms.location.LocationResult) {
                        locationResult.lastLocation?.let { location ->
                            _location.value = location
                        }
                    }
                },
                null
            )
        } catch (e: Exception) {
            // Handle permission or other errors
        }
    }

    fun stopLocationUpdates() {
        fusedLocationClient.removeLocationUpdates(object : com.google.android.gms.location.LocationCallback() {
            override fun onLocationResult(locationResult: com.google.android.gms.location.LocationResult) {
                // Not used
            }
        })
    }

    @SuppressLint("MissingPermission")
    suspend fun getLastLocation(): Location? {
        return try {
            fusedLocationClient.lastLocation.await()
        } catch (e: Exception) {
            null
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/MeasurementService.cs
# TYP: .cs
================================================================================
// MeasurementService.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Services/MeasurementService.kt
# TYP: .kt
================================================================================
package com.emfad.app.Services

import com.emfad.app.Models.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import java.util.UUID

class MeasurementService {
    private val _currentSession = MutableStateFlow<MeasurementSession?>(null)
    val currentSession: StateFlow<MeasurementSession?> = _currentSession

    private val _currentProfile = MutableStateFlow<MeasurementProfile?>(null)
    val currentProfile: StateFlow<MeasurementProfile?> = _currentProfile

    fun startNewSession(
        name: String,
        settings: MeasurementSettings
    ): MeasurementSession {
        val session = MeasurementSession(
            id = UUID.randomUUID().toString(),
            name = name,
            profiles = emptyList(),
            startTime = System.currentTimeMillis(),
            endTime = null,
            settings = settings
        )
        _currentSession.value = session
        return session
    }

    fun endCurrentSession() {
        _currentSession.value?.let { session ->
            _currentSession.value = session.copy(
                endTime = System.currentTimeMillis()
            )
        }
    }

    fun startNewProfile(
        name: String,
        profileLength: Double,
        distance: Double
    ): MeasurementProfile {
        val profile = MeasurementProfile(
            id = UUID.randomUUID().toString(),
            name = name,
            measurements = emptyList(),
            profileLength = profileLength,
            distance = distance
        )
        _currentProfile.value = profile
        return profile
    }

    fun addMeasurement(
        value: Double,
        latitude: Double? = null,
        longitude: Double? = null
    ) {
        _currentProfile.value?.let { profile ->
            val measurement = MeasurementData(
                id = UUID.randomUUID().toString(),
                timestamp = System.currentTimeMillis(),
                frequency = _currentSession.value?.settings?.frequency ?: 0.0,
                mode = _currentSession.value?.settings?.mode ?: MeasurementMode.A,
                orientation = _currentSession.value?.settings?.orientation ?: MeasurementOrientation.HORIZONTAL,
                value = value,
                latitude = latitude,
                longitude = longitude
            )

            val updatedProfile = profile.copy(
                measurements = profile.measurements + measurement
            )
            _currentProfile.value = updatedProfile

            _currentSession.value?.let { session ->
                val updatedProfiles = session.profiles.toMutableList()
                val profileIndex = updatedProfiles.indexOfFirst { it.id == profile.id }
                if (profileIndex >= 0) {
                    updatedProfiles[profileIndex] = updatedProfile
                } else {
                    updatedProfiles.add(updatedProfile)
                }
                _currentSession.value = session.copy(profiles = updatedProfiles)
            }
        }
    }

    fun endCurrentProfile() {
        _currentProfile.value = null
    }

    fun applyFilter(measurements: List<MeasurementData>, filterLevel: Int): List<MeasurementData> {
        if (filterLevel <= 0) return measurements

        return measurements.windowed(filterLevel, 1, true) { window ->
            val filteredValue = window.map { it.value }.average()
            window.first().copy(value = filteredValue)
        }
    }

    fun calculateStatistics(measurements: List<MeasurementData>): MeasurementStatistics {
        val values = measurements.map { it.value }
        return MeasurementStatistics(
            min = values.minOrNull() ?: 0.0,
            max = values.maxOrNull() ?: 0.0,
            average = values.average(),
            standardDeviation = calculateStandardDeviation(values)
        )
    }

    private fun calculateStandardDeviation(values: List<Double>): Double {
        val mean = values.average()
        val variance = values.map { (it - mean) * (it - mean) }.average()
        return kotlin.math.sqrt(variance)
    }
}

data class MeasurementStatistics(
    val min: Double,
    val max: Double,
    val average: Double,
    val standardDeviation: Double
) 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: ViewModels/BluetoothViewModel.cs
# TYP: .cs
================================================================================
// BluetoothViewModel.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: ViewModels/GPSViewModel.cs
# TYP: .cs
================================================================================
// GPSViewModel.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: ViewModels/MainViewModel.kt
# TYP: .kt
================================================================================
package com.emfad.app.ViewModels

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.emfad.app.Models.*
import com.emfad.app.Services.BluetoothService
import com.emfad.app.Services.LocationService
import com.emfad.app.Services.MeasurementService
import kotlinx.coroutines.flow.*
import kotlinx.coroutines.launch

class MainViewModel(application: Application) : AndroidViewModel(application) {
    private val bluetoothService = BluetoothService(application)
    private val locationService = LocationService(application)
    private val measurementService = MeasurementService()

    private val _uiState = MutableStateFlow<UiState>(UiState.Initial)
    val uiState: StateFlow<UiState> = _uiState

    private val _currentSettings = MutableStateFlow(
        MeasurementSettings(
            frequency = 70.0, // kHz
            mode = MeasurementMode.A,
            orientation = MeasurementOrientation.HORIZONTAL,
            autoInterval = null,
            filterLevel = 0,
            gain = 1.0,
            offset = 0.0
        )
    )
    val currentSettings: StateFlow<MeasurementSettings> = _currentSettings

    init {
        viewModelScope.launch {
            combine(
                bluetoothService.connectionState,
                bluetoothService.measurementData,
                locationService.location,
                measurementService.currentSession,
                measurementService.currentProfile
            ) { connectionState, measurementData, location, session, profile ->
                when (connectionState) {
                    is BluetoothService.ConnectionState.Connected -> {
                        measurementData?.let { data ->
                            // Parse measurement data and update UI
                            val value = parseMeasurementValue(data)
                            measurementService.addMeasurement(
                                value = value,
                                latitude = location?.latitude,
                                longitude = location?.longitude
                            )
                        }
                    }
                    is BluetoothService.ConnectionState.Disconnected -> {
                        _uiState.value = UiState.Disconnected
                    }
                    is BluetoothService.ConnectionState.Error -> {
                        _uiState.value = UiState.Error(connectionState.message)
                    }
                }
            }.collect()
        }
    }

    fun startMeasurement() {
        viewModelScope.launch {
            try {
                locationService.startLocationUpdates()
                measurementService.startNewSession(
                    name = "Measurement_${System.currentTimeMillis()}",
                    settings = _currentSettings.value
                )
                _uiState.value = UiState.Measuring
            } catch (e: Exception) {
                _uiState.value = UiState.Error(e.message ?: "Unknown error")
            }
        }
    }

    fun stopMeasurement() {
        viewModelScope.launch {
            locationService.stopLocationUpdates()
            measurementService.endCurrentSession()
            _uiState.value = UiState.Connected
        }
    }

    fun startNewProfile(profileLength: Double, distance: Double) {
        measurementService.startNewProfile(
            name = "Profile_${System.currentTimeMillis()}",
            profileLength = profileLength,
            distance = distance
        )
    }

    fun endCurrentProfile() {
        measurementService.endCurrentProfile()
    }

    fun updateSettings(settings: MeasurementSettings) {
        _currentSettings.value = settings
    }

    private fun parseMeasurementValue(data: ByteArray): Double {
        // Implement parsing logic based on EMFAD protocol
        // This is a placeholder implementation
        return data[0].toDouble()
    }

    sealed class UiState {
        object Initial : UiState()
        object Connected : UiState()
        object Measuring : UiState()
        object Disconnected : UiState()
        data class Error(val message: String) : UiState()
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: ViewModels/MeasurementViewModel.cs
# TYP: .cs
================================================================================
// MeasurementViewModel.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: ViewModels/VisualizationViewModel.cs
# TYP: .cs
================================================================================
// VisualizationViewModel.cs Inhalt

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Views/BluetoothPage.xaml
# TYP: .xaml
================================================================================
<ContentPage><!-- BluetoothPage.xaml wie zuvor bereitgestellt --></ContentPage>

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Views/GPSPage.xaml
# TYP: .xaml
================================================================================
<ContentPage><!-- GPSPage.xaml Inhalt --></ContentPage>

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Views/MainScreen.kt
# TYP: .kt
================================================================================
package com.emfad.app.Views

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.emfad.app.Models.*
import com.emfad.app.ViewModels.MainViewModel
import com.github.tehras.charts.line.LineChart
import com.github.tehras.charts.line.LineChartData
import com.github.tehras.charts.line.rememberLineChartState

@Composable
fun MainScreen(viewModel: MainViewModel) {
    val uiState by viewModel.uiState.collectAsState()
    val settings by viewModel.currentSettings.collectAsState()
    var showSettings by remember { mutableStateOf(false) }

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Status Bar
        StatusBar(uiState)

        // Measurement Display
        MeasurementDisplay(viewModel)

        // Control Buttons
        ControlButtons(
            uiState = uiState,
            onStartMeasurement = { viewModel.startMeasurement() },
            onStopMeasurement = { viewModel.stopMeasurement() },
            onSettingsClick = { showSettings = true }
        )

        // Settings Dialog
        if (showSettings) {
            SettingsDialog(
                settings = settings,
                onSettingsChanged = { viewModel.updateSettings(it) },
                onDismiss = { showSettings = false }
            )
        }
    }
}

@Composable
private fun StatusBar(uiState: MainViewModel.UiState) {
    val (backgroundColor, text) = when (uiState) {
        is MainViewModel.UiState.Connected -> MaterialTheme.colorScheme.primary to "Verbunden"
        is MainViewModel.UiState.Measuring -> MaterialTheme.colorScheme.tertiary to "Messung l√§uft"
        is MainViewModel.UiState.Disconnected -> MaterialTheme.colorScheme.error to "Nicht verbunden"
        is MainViewModel.UiState.Error -> MaterialTheme.colorScheme.error to "Fehler: ${uiState.message}"
        MainViewModel.UiState.Initial -> MaterialTheme.colorScheme.surface to "Bereit"
    }

    Surface(
        modifier = Modifier
            .fillMaxWidth()
            .padding(bottom = 16.dp),
        color = backgroundColor
    ) {
        Text(
            text = text,
            modifier = Modifier.padding(8.dp),
            color = MaterialTheme.colorScheme.onPrimary
        )
    }
}

@Composable
private fun MeasurementDisplay(viewModel: MainViewModel) {
    // Placeholder for measurement visualization
    // This will be replaced with actual measurement data visualization
    Box(
        modifier = Modifier
            .fillMaxWidth()
            .height(200.dp)
            .padding(16.dp),
        contentAlignment = Alignment.Center
    ) {
        Text("Messwerte werden hier angezeigt")
    }
}

@Composable
private fun ControlButtons(
    uiState: MainViewModel.UiState,
    onStartMeasurement: () -> Unit,
    onStopMeasurement: () -> Unit,
    onSettingsClick: () -> Unit
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(16.dp),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        Button(
            onClick = onSettingsClick,
            enabled = uiState !is MainViewModel.UiState.Measuring
        ) {
            Text("Einstellungen")
        }

        when (uiState) {
            is MainViewModel.UiState.Connected -> {
                Button(onClick = onStartMeasurement) {
                    Text("Messung starten")
                }
            }
            is MainViewModel.UiState.Measuring -> {
                Button(
                    onClick = onStopMeasurement,
                    colors = ButtonDefaults.buttonColors(
                        containerColor = MaterialTheme.colorScheme.error
                    )
                ) {
                    Text("Messung beenden")
                }
            }
            else -> {
                // No action buttons for other states
            }
        }
    }
}

@Composable
private fun SettingsDialog(
    settings: MeasurementSettings,
    onSettingsChanged: (MeasurementSettings) -> Unit,
    onDismiss: () -> Unit
) {
    var frequency by remember { mutableStateOf(settings.frequency.toString()) }
    var mode by remember { mutableStateOf(settings.mode) }
    var orientation by remember { mutableStateOf(settings.orientation) }
    var filterLevel by remember { mutableStateOf(settings.filterLevel.toString()) }
    var gain by remember { mutableStateOf(settings.gain.toString()) }
    var offset by remember { mutableStateOf(settings.offset.toString()) }

    AlertDialog(
        onDismissRequest = onDismiss,
        title = { Text("Einstellungen") },
        text = {
            Column {
                OutlinedTextField(
                    value = frequency,
                    onValueChange = { frequency = it },
                    label = { Text("Frequenz (kHz)") }
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text("Messmodus")
                Row {
                    MeasurementMode.values().forEach { measurementMode ->
                        RadioButton(
                            selected = mode == measurementMode,
                            onClick = { mode = measurementMode }
                        )
                        Text(measurementMode.name)
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                Text("Orientierung")
                Row {
                    MeasurementOrientation.values().forEach { measurementOrientation ->
                        RadioButton(
                            selected = orientation == measurementOrientation,
                            onClick = { orientation = measurementOrientation }
                        )
                        Text(measurementOrientation.name)
                    }
                }
                
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = filterLevel,
                    onValueChange = { filterLevel = it },
                    label = { Text("Filterstufe") }
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = gain,
                    onValueChange = { gain = it },
                    label = { Text("Verst√§rkung") }
                )
                
                Spacer(modifier = Modifier.height(8.dp))
                
                OutlinedTextField(
                    value = offset,
                    onValueChange = { offset = it },
                    label = { Text("Offset") }
                )
            }
        },
        confirmButton = {
            Button(
                onClick = {
                    onSettingsChanged(
                        settings.copy(
                            frequency = frequency.toDoubleOrNull() ?: settings.frequency,
                            mode = mode,
                            orientation = orientation,
                            filterLevel = filterLevel.toIntOrNull() ?: settings.filterLevel,
                            gain = gain.toDoubleOrNull() ?: settings.gain,
                            offset = offset.toDoubleOrNull() ?: settings.offset
                        )
                    )
                    onDismiss()
                }
            ) {
                Text("OK")
            }
        },
        dismissButton = {
            TextButton(onClick = onDismiss) {
                Text("Abbrechen")
            }
        }
    )
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Views/MeasurementPage.xaml
# TYP: .xaml
================================================================================
<ContentPage>MeasurementPage.xaml Inhalt</ContentPage>

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: Views/VisualizationPage.xaml
# TYP: .xaml
================================================================================
<ContentPage><!-- VisualizationPage.xaml Inhalt --></ContentPage>

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/build.gradle
# TYP: .gradle
================================================================================
plugins {
    id 'com.android.application'
    id 'org.jetbrains.kotlin.android'
}

android {
    namespace 'com.emfad.app'
    compileSdk 34

    defaultConfig {
        applicationId "com.emfad.app"
        minSdk 24
        targetSdk 34
        versionCode getVersionCode()
        versionName getVersionName()

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
        vectorDrawables {
            useSupportLibrary true
        }
    }

    signingConfigs {
        debug {
            // Default debug keystore - always available
        }
        release {
            // Only configure signing if all required environment variables are present
            if (hasSigningConfig()) {
                storeFile file(System.getenv("CM_KEYSTORE_PATH"))
                storePassword System.getenv("CM_KEYSTORE_PASSWORD")
                keyAlias System.getenv("CM_KEY_ALIAS")
                keyPassword System.getenv("CM_KEY_PASSWORD")
            }
        }
    }

    buildTypes {
        debug {
            applicationIdSuffix ".debug"
            debuggable true
            minifyEnabled false
            signingConfig signingConfigs.debug
        }
        release {
            minifyEnabled true
            shrinkResources true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            
            if (hasSigningConfig()) {
                signingConfig signingConfigs.release
            } else {
                signingConfig signingConfigs.debug
            }
        }
    }

    compileOptions {
        sourceCompatibility JavaVersion.VERSION_1_8
        targetCompatibility JavaVersion.VERSION_1_8
    }
    
    kotlinOptions {
        jvmTarget = '1.8'
    }

    buildFeatures {
        compose true
    }
    
    composeOptions {
        kotlinCompilerExtensionVersion '1.5.8'
    }
    
    packaging {
        resources {
            excludes += '/META-INF/{AL2.0,LGPL2.1}'
        }
    }

    // Test options for CI
    testOptions {
        unitTests {
            includeAndroidResources = true
            returnDefaultValues = true
        }
        animationsDisabled = true
    }

    // Lint options
    lint {
        abortOnError false
        xmlReport true
        htmlReport true
    }
}

dependencies {
    implementation 'androidx.core:core-ktx:1.12.0'
    implementation 'androidx.lifecycle:lifecycle-runtime-ktx:2.7.0'
    implementation 'androidx.activity:activity-compose:1.8.2'
    
    // Jetpack Compose BOM - this manages all compose versions
    implementation platform('androidx.compose:compose-bom:2024.02.00')
    implementation 'androidx.compose.ui:ui'
    implementation 'androidx.compose.ui:ui-tooling-preview'
    implementation 'androidx.compose.material3:material3'
    
    // Navigation Compose - REQUIRED for your MainActivity
    implementation 'androidx.navigation:navigation-compose:2.7.6'
    
    // ViewModel Compose
    implementation 'androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0'
    
    // Optional but recommended
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'com.google.android.material:material:1.11.0'
    
    // Testing
    testImplementation 'junit:junit:4.13.2'
    androidTestImplementation 'androidx.test.ext:junit:1.1.5'
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.5.1'
    androidTestImplementation platform('androidx.compose:compose-bom:2024.02.00')
    androidTestImplementation 'androidx.compose.ui:ui-test-junit4'
    debugImplementation 'androidx.compose.ui:ui-tooling'
    debugImplementation 'androidx.compose.ui:ui-test-manifest'
}

// Helper function to check if signing config is available
def hasSigningConfig() {
    return System.getenv("CM_KEYSTORE_PATH") && 
           System.getenv("CM_KEYSTORE_PASSWORD") && 
           System.getenv("CM_KEY_ALIAS") && 
           System.getenv("CM_KEY_PASSWORD")
}

// Version Code/Name for CI
def getVersionCode() {
    def buildId = System.getenv("CM_BUILD_ID")
    if (buildId != null && buildId.isInteger()) {
        return buildId as Integer
    }
    return 1
}

def getVersionName() {
    def tag = System.getenv("CM_TAG")
    if (tag != null && !tag.isEmpty()) {
        return tag
    }
    return "1.0.0-SNAPSHOT"
}


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/proguard-rules.pro
# TYP: .pro
================================================================================
# Add project specific ProGuard rules here.
-keep class com.emfad.app.** { *; }
-keepclassmembers class com.emfad.app.** { *; }

# Keep Bluetooth classes
-keep class android.bluetooth.** { *; }

# Keep Compose classes
-keep class androidx.compose.** { *; }
-keep class androidx.navigation.** { *; }


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/AndroidManifest.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- Bluetooth Berechtigungen -->
    <uses-permission android:name="android.permission.BLUETOOTH" />
    <uses-permission android:name="android.permission.BLUETOOTH_ADMIN" />
    <uses-permission android:name="android.permission.BLUETOOTH_CONNECT" />
    <uses-permission android:name="android.permission.BLUETOOTH_SCAN" />
    
    <!-- Standort-Berechtigungen (f√ºr Bluetooth-Scanning auf Android 12+) -->
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    
    <!-- Internet-Berechtigung f√ºr m√∂gliche Updates -->
    <uses-permission android:name="android.permission.INTERNET" />
    
    <!-- Media-Berechtigungen f√ºr Android 13+ -->
    <uses-permission android:name="android.permission.READ_MEDIA_IMAGES" />
    <uses-permission android:name="android.permission.READ_MEDIA_VIDEO" />
    <uses-permission android:name="android.permission.READ_MEDIA_AUDIO" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.EMFADApp"
        tools:targetApi="31">
        
        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:theme="@style/Theme.EMFADApp">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>
</manifest>


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/MainActivity.kt
# TYP: .kt
================================================================================
package com.emfad.app

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import androidx.navigation.compose.rememberNavController
import com.emfad.app.navigation.AppNavigation
import com.emfad.app.ui.theme.EMFADAppTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            EMFADAppTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    val navController = rememberNavController()
                    AppNavigation(navController)
                }
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/bluetooth/BluetoothManager.kt
# TYP: .kt
================================================================================
package com.emfad.app.bluetooth

import android.Manifest
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothSocket
import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import androidx.core.app.ActivityCompat
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import java.io.IOException
import java.util.*

class BluetoothManager(private val context: Context) {
    private val TAG = "BluetoothManager"
    private val SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")
    
    private val bluetoothAdapter: BluetoothAdapter? = BluetoothAdapter.getDefaultAdapter()
    private var bluetoothSocket: BluetoothSocket? = null
    
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState
    
    private val _receivedData = MutableStateFlow<String>("")
    val receivedData: StateFlow<String> = _receivedData

    private val _availableDevices = MutableStateFlow<List<BluetoothDevice>>(emptyList())
    val availableDevices: StateFlow<List<BluetoothDevice>> = _availableDevices

    sealed class ConnectionState {
        object CONNECTED : ConnectionState()
        object DISCONNECTED : ConnectionState()
        object CONNECTING : ConnectionState()
        object SCANNING : ConnectionState()
        data class ERROR(val message: String) : ConnectionState()
    }

    fun startScan() {
        if (!hasRequiredPermissions()) {
            _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
            return
        }

        if (bluetoothAdapter?.isEnabled != true) {
            _connectionState.value = ConnectionState.ERROR("Bluetooth ist deaktiviert")
            return
        }

        _connectionState.value = ConnectionState.SCANNING
        val devices = mutableListOf<BluetoothDevice>()

        try {
            bluetoothAdapter?.bondedDevices?.forEach { device ->
                if (device.name?.contains("EMFAD", ignoreCase = true) == true) {
                    devices.add(device)
                }
            }
            _availableDevices.value = devices
        } catch (e: SecurityException) {
            Log.e(TAG, "Berechtigungsfehler beim Scannen: ${e.message}")
            _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
        }
    }

    fun connectToDevice(device: BluetoothDevice) {
        if (!hasRequiredPermissions()) {
            _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
            return
        }

        if (bluetoothAdapter?.isEnabled != true) {
            _connectionState.value = ConnectionState.ERROR("Bluetooth ist deaktiviert")
            return
        }

        _connectionState.value = ConnectionState.CONNECTING
        
        try {
            bluetoothSocket = device.createRfcommSocketToServiceRecord(SPP_UUID)
            bluetoothSocket?.connect()
            _connectionState.value = ConnectionState.CONNECTED
            startListening()
        } catch (e: IOException) {
            Log.e(TAG, "Verbindungsfehler: ${e.message}")
            _connectionState.value = ConnectionState.ERROR(e.message ?: "Unbekannter Fehler")
            closeConnection()
        } catch (e: SecurityException) {
            Log.e(TAG, "Berechtigungsfehler: ${e.message}")
            _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
            closeConnection()
        }
    }

    fun sendData(data: String) {
        if (!hasRequiredPermissions() || _connectionState.value != ConnectionState.CONNECTED) {
            _connectionState.value = ConnectionState.ERROR("Nicht verbunden oder Berechtigungen fehlen")
            return
        }

        try {
            bluetoothSocket?.outputStream?.write(data.toByteArray())
        } catch (e: IOException) {
            Log.e(TAG, "Fehler beim Senden: ${e.message}")
            _connectionState.value = ConnectionState.ERROR("Fehler beim Senden der Daten")
            closeConnection()
        } catch (e: SecurityException) {
            Log.e(TAG, "Berechtigungsfehler beim Senden: ${e.message}")
            _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
            closeConnection()
        }
    }

    private fun hasRequiredPermissions(): Boolean {
        return ActivityCompat.checkSelfPermission(
            context,
            Manifest.permission.BLUETOOTH_CONNECT
        ) == PackageManager.PERMISSION_GRANTED &&
        ActivityCompat.checkSelfPermission(
            context,
            Manifest.permission.BLUETOOTH_SCAN
        ) == PackageManager.PERMISSION_GRANTED
    }

    private fun startListening() {
        Thread {
            val buffer = ByteArray(1024)
            while (_connectionState.value == ConnectionState.CONNECTED) {
                try {
                    if (!hasRequiredPermissions()) {
                        _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
                        break
                    }
                    
                    val bytes = bluetoothSocket?.inputStream?.read(buffer)
                    if (bytes != null && bytes > 0) {
                        val data = String(buffer, 0, bytes)
                        _receivedData.value = data
                    }
                } catch (e: IOException) {
                    Log.e(TAG, "Lesefehler: ${e.message}")
                    _connectionState.value = ConnectionState.ERROR(e.message ?: "Lesefehler")
                    break
                } catch (e: SecurityException) {
                    Log.e(TAG, "Berechtigungsfehler: ${e.message}")
                    _connectionState.value = ConnectionState.ERROR("Bluetooth-Berechtigungen fehlen")
                    break
                }
            }
        }.start()
    }

    fun closeConnection() {
        try {
            if (hasRequiredPermissions()) {
                bluetoothSocket?.close()
            }
        } catch (e: IOException) {
            Log.e(TAG, "Fehler beim Schlie√üen der Verbindung: ${e.message}")
        } catch (e: SecurityException) {
            Log.e(TAG, "Berechtigungsfehler beim Schlie√üen: ${e.message}")
        } finally {
            bluetoothSocket = null
            _connectionState.value = ConnectionState.DISCONNECTED
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/bluetooth/EMFADDevice.kt
# TYP: .kt
================================================================================
package com.emfad.app.bluetooth

import android.bluetooth.BluetoothDevice
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow

data class EMFADDevice(
    val bluetoothDevice: BluetoothDevice,
    val name: String = bluetoothDevice.name ?: "Unbekanntes Ger√§t",
    val address: String = bluetoothDevice.address,
    val rssi: Int = 0
) {
    private val _isConnected = MutableStateFlow(false)
    val isConnected: StateFlow<Boolean> = _isConnected

    private val _batteryLevel = MutableStateFlow<Int?>(null)
    val batteryLevel: StateFlow<Int?> = _batteryLevel

    private val _signalStrength = MutableStateFlow<Int?>(null)
    val signalStrength: StateFlow<Int?> = _signalStrength

    private val _measurementMode = MutableStateFlow<MeasurementMode>(MeasurementMode.UNKNOWN)
    val measurementMode: StateFlow<MeasurementMode> = _measurementMode

    fun updateConnectionState(connected: Boolean) {
        _isConnected.value = connected
    }

    fun updateBatteryLevel(level: Int) {
        _batteryLevel.value = level.coerceIn(0, 100)
    }

    fun updateSignalStrength(strength: Int) {
        _signalStrength.value = strength.coerceIn(-100, 0)
    }

    fun updateMeasurementMode(mode: MeasurementMode) {
        _measurementMode.value = mode
    }

    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is EMFADDevice) return false
        return address == other.address
    }

    override fun hashCode(): Int {
        return address.hashCode()
    }
}

enum class MeasurementMode {
    FERROUS_METAL,
    NON_FERROUS_METAL,
    CAVITY,
    UNKNOWN
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/data/MeasurementDatabase.kt
# TYP: .kt
================================================================================
package com.emfad.app.data

import androidx.room.*
import java.util.*

@Entity(tableName = "measurements")
data class Measurement(
    @PrimaryKey(autoGenerate = true) val id: Long = 0,
    val timestamp: Date,
    val value: Double,
    val unit: String,
    val deviceId: String
)

@Dao
interface MeasurementDao {
    @Query("SELECT * FROM measurements ORDER BY timestamp DESC")
    suspend fun getAllMeasurements(): List<Measurement>

    @Insert
    suspend fun insertMeasurement(measurement: Measurement)

    @Query("SELECT * FROM measurements WHERE timestamp BETWEEN :startTime AND :endTime")
    suspend fun getMeasurementsInRange(startTime: Date, endTime: Date): List<Measurement>
}

@Database(entities = [Measurement::class], version = 1)
abstract class MeasurementDatabase : RoomDatabase() {
    abstract fun measurementDao(): MeasurementDao

    companion object {
        @Volatile
        private var INSTANCE: MeasurementDatabase? = null

        fun getDatabase(context: android.content.Context): MeasurementDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    MeasurementDatabase::class.java,
                    "measurement_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/AnalysisThresholds.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import androidx.datastore.preferences.core.floatPreferencesKey
import androidx.datastore.preferences.core.stringPreferencesKey

data class AnalysisThresholds(
    val magneticFieldMetalThreshold: Float = 50f,
    val electricFieldCavityThreshold: Float = 30f,
    val confidenceThreshold: Float = 0.7f,
    val trendWindowSize: Int = 5
) {
    companion object {
        val MAGNETIC_FIELD_THRESHOLD_KEY = floatPreferencesKey("magnetic_field_threshold")
        val ELECTRIC_FIELD_THRESHOLD_KEY = floatPreferencesKey("electric_field_threshold")
        val CONFIDENCE_THRESHOLD_KEY = floatPreferencesKey("confidence_threshold")
        val TREND_WINDOW_SIZE_KEY = stringPreferencesKey("trend_window_size")
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/AutomaticCalibration.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.abs
import kotlin.math.sqrt

data class CalibrationResult(
    val success: Boolean,
    val calibrationFactor: Double,
    val confidence: Double,
    val mode: MeasurementMode,
    val timestamp: Long = System.currentTimeMillis()
)

data class CalibrationPoint(
    val position: Point3D,
    val impedance: Complex,
    val frequency: Double,
    val mode: MeasurementMode
)

class AutomaticCalibration {
    companion object {
        private const val MIN_CALIBRATION_POINTS = 3
        private const val MAX_CALIBRATION_POINTS = 10
        private const val MIN_CONFIDENCE = 0.7
    }
    
    private val calibrationPoints = mutableListOf<CalibrationPoint>()
    private var currentMode: MeasurementMode = MeasurementMode.BA_VERTICAL
    
    fun setMode(mode: MeasurementMode) {
        currentMode = mode
        calibrationPoints.clear()
    }
    
    fun addCalibrationPoint(point: CalibrationPoint) {
        if (point.mode != currentMode) {
            throw IllegalArgumentException("Kalibrierungspunkt muss zum aktuellen Modus passen")
        }
        
        if (calibrationPoints.size >= MAX_CALIBRATION_POINTS) {
            calibrationPoints.removeAt(0)
        }
        
        calibrationPoints.add(point)
    }
    
    fun removeCalibrationPoint(index: Int) {
        if (index in calibrationPoints.indices) {
            calibrationPoints.removeAt(index)
        }
    }
    
    fun calibrate(): CalibrationResult {
        if (calibrationPoints.size < MIN_CALIBRATION_POINTS) {
            return CalibrationResult(
                success = false,
                calibrationFactor = 1.0,
                confidence = 0.0,
                mode = currentMode
            )
        }
        
        // 1. Berechne Kalibrierungsfaktor
        val calibrationFactor = calculateCalibrationFactor()
        
        // 2. Berechne Zuverl√§ssigkeit
        val confidence = calculateCalibrationConfidence(calibrationFactor)
        
        return CalibrationResult(
            success = confidence >= MIN_CONFIDENCE,
            calibrationFactor = calibrationFactor,
            confidence = confidence,
            mode = currentMode
        )
    }
    
    private fun calculateCalibrationFactor(): Double {
        // Berechne durchschnittlichen Kalibrierungsfaktor
        val factors = calibrationPoints.map { point ->
            calculatePointCalibrationFactor(point)
        }
        
        // Entferne Ausrei√üer
        val filteredFactors = removeOutliers(factors)
        
        return filteredFactors.average()
    }
    
    private fun calculatePointCalibrationFactor(point: CalibrationPoint): Double {
        // Berechne Kalibrierungsfaktor f√ºr einen einzelnen Punkt
        val expectedImpedance = when (point.mode) {
            MeasurementMode.BA_VERTICAL -> Complex(377.0, 0.0)
            MeasurementMode.AB_HORIZONTAL -> Complex(377.0, 0.0)
            MeasurementMode.ANTENNA_A -> Complex(377.0, 0.0)
            MeasurementMode.DEPTH_PRO -> Complex(377.0, 0.0)
        }
        
        return expectedImpedance.magnitude / point.impedance.magnitude
    }
    
    private fun removeOutliers(values: List<Double>): List<Double> {
        if (values.size <= 2) return values
        
        val mean = values.average()
        val stdDev = sqrt(values.map { (it - mean).pow(2) }.average())
        
        return values.filter { abs(it - mean) <= 2 * stdDev }
    }
    
    private fun calculateCalibrationConfidence(calibrationFactor: Double): Double {
        var confidence = 0.0
        
        // 1. Anzahl der Kalibrierungspunkte (30%)
        val pointConfidence = (calibrationPoints.size.toDouble() / MAX_CALIBRATION_POINTS)
            .coerceIn(0.0, 1.0)
        confidence += 0.3 * pointConfidence
        
        // 2. Streuung der Kalibrierungsfaktoren (30%)
        val factors = calibrationPoints.map { calculatePointCalibrationFactor(it) }
        val mean = factors.average()
        val stdDev = sqrt(factors.map { (it - mean).pow(2) }.average())
        val spreadConfidence = (1.0 - stdDev / mean).coerceIn(0.0, 1.0)
        confidence += 0.3 * spreadConfidence
        
        // 3. Abweichung vom erwarteten Faktor (20%)
        val factorDeviation = abs(calibrationFactor - 1.0)
        val factorConfidence = (1.0 - factorDeviation).coerceIn(0.0, 1.0)
        confidence += 0.2 * factorConfidence
        
        // 4. Frequenzabh√§ngigkeit (20%)
        val frequencies = calibrationPoints.map { it.frequency }
        val freqStdDev = sqrt(frequencies.map { (it - frequencies.average()).pow(2) }.average())
        val freqConfidence = (1.0 - freqStdDev / frequencies.average()).coerceIn(0.0, 1.0)
        confidence += 0.2 * freqConfidence
        
        return confidence.coerceIn(0.0, 1.0)
    }
    
    fun getCalibrationPoints(): List<CalibrationPoint> = calibrationPoints.toList()
    
    fun clearCalibrationPoints() {
        calibrationPoints.clear()
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/ClusterAnalyzer.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.sqrt
import kotlin.math.pow

data class MeasurementPoint(
    val impedance: Complex,
    val conductivity: Double,
    val permittivity: Complex,
    val permeability: Double,
    val depth: Double,
    val position: Point3D
)

data class Point3D(val x: Double, val y: Double, val z: Double) {
    fun distanceTo(other: Point3D): Double {
        return sqrt(
            (x - other.x).pow(2) +
            (y - other.y).pow(2) +
            (z - other.z).pow(2)
        )
    }
}

data class ClusterAnalysisResult(
    val clusters: List<Cluster>,
    val outliers: List<MeasurementPoint>,
    val confidence: Double
)

data class Cluster(
    val points: List<MeasurementPoint>,
    val centroid: Point3D,
    val radius: Double,
    val type: ClusterType
)

enum class ClusterType {
    NATURAL_VEIN,
    ARTIFICIAL_STRUCTURE,
    CRYSTAL_FORMATION,
    UNKNOWN
}

class ClusterAnalyzer {
    companion object {
        private const val OUTLIER_THRESHOLD = 2.0 // Standardabweichungen
        private const val MIN_CLUSTER_SIZE = 3
        private const val MAX_CLUSTER_RADIUS = 2.0 // Meter
    }
    
    fun analyzeClusters(points: List<MeasurementPoint>): ClusterAnalysisResult {
        // 1. Berechne Distanzmatrix
        val distanceMatrix = calculateDistanceMatrix(points)
        
        // 2. Identifiziere Outlier
        val (clusters, outliers) = identifyClustersAndOutliers(points, distanceMatrix)
        
        // 3. Bestimme Clustertypen
        val typedClusters = clusters.map { cluster ->
            cluster.copy(type = determineClusterType(cluster))
        }
        
        // 4. Berechne Gesamtzuverl√§ssigkeit
        val confidence = calculateConfidence(typedClusters, outliers)
        
        return ClusterAnalysisResult(
            clusters = typedClusters,
            outliers = outliers,
            confidence = confidence
        )
    }
    
    private fun calculateDistanceMatrix(points: List<MeasurementPoint>): Array<DoubleArray> {
        val n = points.size
        val matrix = Array(n) { DoubleArray(n) }
        
        for (i in 0 until n) {
            for (j in i + 1 until n) {
                val distance = calculateFeatureDistance(points[i], points[j])
                matrix[i][j] = distance
                matrix[j][i] = distance
            }
        }
        
        return matrix
    }
    
    private fun calculateFeatureDistance(a: MeasurementPoint, b: MeasurementPoint): Double {
        // Gewichtete euklidische Distanz der Features
        val weights = mapOf(
            "impedance" to 0.3,
            "conductivity" to 0.2,
            "permittivity" to 0.2,
            "permeability" to 0.1,
            "depth" to 0.2
        )
        
        val impedanceDist = (a.impedance - b.impedance).magnitude
        val conductivityDist = (a.conductivity - b.conductivity).pow(2)
        val permittivityDist = (a.permittivity - b.permittivity).magnitude
        val permeabilityDist = (a.permeability - b.permeability).pow(2)
        val depthDist = (a.depth - b.depth).pow(2)
        val spatialDist = a.position.distanceTo(b.position)
        
        return sqrt(
            weights["impedance"]!! * impedanceDist.pow(2) +
            weights["conductivity"]!! * conductivityDist +
            weights["permittivity"]!! * permittivityDist.pow(2) +
            weights["permeability"]!! * permeabilityDist +
            weights["depth"]!! * depthDist +
            spatialDist.pow(2)
        )
    }
    
    private fun identifyClustersAndOutliers(
        points: List<MeasurementPoint>,
        distanceMatrix: Array<DoubleArray>
    ): Pair<List<Cluster>, List<MeasurementPoint>> {
        val n = points.size
        val visited = BooleanArray(n)
        val clusters = mutableListOf<Cluster>()
        val outliers = mutableListOf<MeasurementPoint>()
        
        // Berechne Durchschnittsdistanz und Standardabweichung
        val distances = distanceMatrix.flatMap { it.toList() }.filter { it > 0 }
        val meanDistance = distances.average()
        val stdDev = sqrt(distances.map { (it - meanDistance).pow(2) }.average())
        
        // DBSCAN-√§hnlicher Algorithmus
        for (i in 0 until n) {
            if (visited[i]) continue
            
            val neighbors = mutableListOf<Int>()
            for (j in 0 until n) {
                if (distanceMatrix[i][j] < meanDistance + OUTLIER_THRESHOLD * stdDev) {
                    neighbors.add(j)
                }
            }
            
            if (neighbors.size >= MIN_CLUSTER_SIZE) {
                // Erstelle Cluster
                val clusterPoints = neighbors.map { points[it] }
                val centroid = calculateCentroid(clusterPoints)
                val radius = calculateClusterRadius(clusterPoints, centroid)
                
                clusters.add(Cluster(
                    points = clusterPoints,
                    centroid = centroid,
                    radius = radius,
                    type = ClusterType.UNKNOWN
                ))
                
                neighbors.forEach { visited[it] = true }
            } else {
                outliers.add(points[i])
                visited[i] = true
            }
        }
        
        return Pair(clusters, outliers)
    }
    
    private fun calculateCentroid(points: List<MeasurementPoint>): Point3D {
        val sumX = points.sumOf { it.position.x }
        val sumY = points.sumOf { it.position.y }
        val sumZ = points.sumOf { it.position.z }
        val n = points.size.toDouble()
        
        return Point3D(sumX / n, sumY / n, sumZ / n)
    }
    
    private fun calculateClusterRadius(
        points: List<MeasurementPoint>,
        centroid: Point3D
    ): Double {
        return points.maxOf { it.position.distanceTo(centroid) }
    }
    
    private fun determineClusterType(cluster: Cluster): ClusterType {
        val points = cluster.points
        
        // Berechne Durchschnittswerte
        val avgConductivity = points.map { it.conductivity }.average()
        val avgDepth = points.map { it.depth }.average()
        val aspectRatio = calculateAspectRatio(points)
        val symmetry = calculateSymmetry(points)
        
        return when {
            // Nat√ºrliche Ader
            avgConductivity > 1e4 && aspectRatio > 10 && symmetry < 0.3 && avgDepth > 1.5 ->
                ClusterType.NATURAL_VEIN
            
            // K√ºnstliche Struktur
            (avgConductivity < 1e-9 || avgConductivity > 1e6) && 
            aspectRatio < 3 && symmetry > 0.7 && avgDepth < 10 ->
                ClusterType.ARTIFICIAL_STRUCTURE
            
            // Kristallformation
            avgConductivity < 1e-10 && symmetry > 0.8 ->
                ClusterType.CRYSTAL_FORMATION
            
            else -> ClusterType.UNKNOWN
        }
    }
    
    private fun calculateAspectRatio(points: List<MeasurementPoint>): Double {
        val xRange = points.map { it.position.x }.let { it.maxOrNull()!! - it.minOrNull()!! }
        val yRange = points.map { it.position.y }.let { it.maxOrNull()!! - it.minOrNull()!! }
        val zRange = points.map { it.position.z }.let { it.maxOrNull()!! - it.minOrNull()!! }
        
        val maxRange = maxOf(xRange, yRange, zRange)
        val minRange = minOf(xRange, yRange, zRange)
        
        return if (minRange > 0) maxRange / minRange else 1.0
    }
    
    private fun calculateSymmetry(points: List<MeasurementPoint>): Double {
        val centroid = calculateCentroid(points)
        val distances = points.map { it.position.distanceTo(centroid) }
        val meanDistance = distances.average()
        val stdDev = sqrt(distances.map { (it - meanDistance).pow(2) }.average())
        
        return 1.0 - (stdDev / meanDistance).coerceIn(0.0, 1.0)
    }
    
    private fun calculateConfidence(
        clusters: List<Cluster>,
        outliers: List<MeasurementPoint>
    ): Double {
        var confidence = 0.0
        
        // 1. Clustergr√∂√üe (30%)
        val avgClusterSize = clusters.map { it.points.size }.average()
        confidence += 0.3 * (avgClusterSize / 10.0).coerceIn(0.0, 1.0)
        
        // 2. Cluster-Trennung (30%)
        val clusterSeparation = calculateClusterSeparation(clusters)
        confidence += 0.3 * clusterSeparation
        
        // 3. Outlier-Anteil (20%)
        val outlierRatio = outliers.size.toDouble() / (clusters.sumOf { it.points.size } + outliers.size)
        confidence += 0.2 * (1.0 - outlierRatio)
        
        // 4. Clustertyp-√úbereinstimmung (20%)
        val typeConfidence = clusters.count { it.type != ClusterType.UNKNOWN }.toDouble() / clusters.size
        confidence += 0.2 * typeConfidence
        
        return confidence.coerceIn(0.0, 1.0)
    }
    
    private fun calculateClusterSeparation(clusters: List<Cluster>): Double {
        if (clusters.size < 2) return 1.0
        
        var minSeparation = Double.MAX_VALUE
        for (i in clusters.indices) {
            for (j in i + 1 until clusters.size) {
                val separation = clusters[i].centroid.distanceTo(clusters[j].centroid) /
                               (clusters[i].radius + clusters[j].radius)
                minSeparation = minOf(minSeparation, separation)
            }
        }
        
        return (minSeparation / 2.0).coerceIn(0.0, 1.0)
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/CrystalDetector.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.abs
import kotlin.math.sqrt

data class Complex(val real: Double, val imag: Double) {
    operator fun times(other: Complex) = Complex(
        real * other.real - imag * other.imag,
        real * other.imag + imag * other.real
    )
    
    operator fun div(other: Complex): Complex {
        val denom = other.real * other.real + other.imag * other.imag
        return Complex(
            (real * other.real + imag * other.imag) / denom,
            (imag * other.real - real * other.imag) / denom
        )
    }
    
    val magnitude: Double get() = sqrt(real * real + imag * imag)
}

data class CrystalDetectionResult(
    val isCrystal: Boolean,
    val confidence: Double,
    val permittivity: Complex,
    val impedanceDelta: Complex,
    val crystalType: CrystalType?
)

enum class CrystalType {
    RUBY, EMERALD, DIAMOND, TOURMALINE, QUARTZ
}

class CrystalDetector {
    companion object {
        private const val ALPHA_MIN = 1.5
        private const val ALPHA_MAX = 2.5
        private const val MU_0 = 4.0 * Math.PI * 1e-7
        private const val EPSILON_0 = 8.854e-12
    }
    
    private val crystalProperties = mapOf(
        CrystalType.RUBY to CrystalProperties(
            density = 3.9..4.1,
            conductivity = 0.0,
            permittivity = Complex(9.3, 0.0)..Complex(10.0, 0.0)
        ),
        CrystalType.EMERALD to CrystalProperties(
            density = 2.7..2.8,
            conductivity = 0.0,
            permittivity = Complex(6.0, 0.0)..Complex(8.0, 0.0)
        ),
        CrystalType.DIAMOND to CrystalProperties(
            density = 3.5..3.6,
            conductivity = 0.0,
            permittivity = Complex(5.5, 0.0)..Complex(7.0, 0.0)
        ),
        CrystalType.TOURMALINE to CrystalProperties(
            density = 3.0..3.3,
            conductivity = 0.0,
            permittivity = Complex(12.0, 0.0)..Complex(15.0, 0.0)
        ),
        CrystalType.QUARTZ to CrystalProperties(
            density = 2.6..2.7,
            conductivity = 0.0,
            permittivity = Complex(4.0, 0.0)..Complex(5.0, 0.0)
        )
    )
    
    fun detectCrystal(
        measuredZ: Complex,
        backgroundZ: Complex,
        frequency: Double,
        noiseStdDev: Double,
        alpha: Double = ALPHA_MIN
    ): CrystalDetectionResult {
        // 1. Berechne Impedanz√§nderung
        val impedanceDelta = measuredZ - backgroundZ
        
        // 2. Berechne lokale Permittivit√§t
        val permittivity = calculateLocalPermittivity(impedanceDelta, frequency)
        
        // 3. Pr√ºfe auf Kristall-Signatur
        val isCrystal = abs(impedanceDelta.magnitude) > alpha * noiseStdDev
        
        // 4. Bestimme Kristalltyp
        val crystalType = if (isCrystal) {
            identifyCrystalType(permittivity)
        } else null
        
        // 5. Berechne Zuverl√§ssigkeit
        val confidence = calculateConfidence(impedanceDelta, noiseStdDev, crystalType)
        
        return CrystalDetectionResult(
            isCrystal = isCrystal,
            confidence = confidence,
            permittivity = permittivity,
            impedanceDelta = impedanceDelta,
            crystalType = crystalType
        )
    }
    
    private fun calculateLocalPermittivity(
        impedanceDelta: Complex,
        frequency: Double
    ): Complex {
        val omega = 2.0 * Math.PI * frequency
        val mu = MU_0 // Vereinfachung: konstante Permeabilit√§t
        
        // Berechne lokale Permittivit√§t aus Impedanz√§nderung
        val epsilonLocal = Complex(
            impedanceDelta.real * impedanceDelta.real + impedanceDelta.imag * impedanceDelta.imag,
            0.0
        ) * Complex(omega * mu / 2.0, 0.0)
        
        return epsilonLocal
    }
    
    private fun identifyCrystalType(permittivity: Complex): CrystalType? {
        return crystalProperties.entries.firstOrNull { (_, props) ->
            permittivity.real in props.permittivity.start.real..props.permittivity.endInclusive.real
        }?.key
    }
    
    private fun calculateConfidence(
        impedanceDelta: Complex,
        noiseStdDev: Double,
        crystalType: CrystalType?
    ): Double {
        var confidence = 0.0
        
        // 1. Signal-Rausch-Verh√§ltnis (40%)
        val snr = impedanceDelta.magnitude / noiseStdDev
        confidence += 0.4 * (snr / 10.0).coerceIn(0.0, 1.0)
        
        // 2. Kristalltyp-√úbereinstimmung (30%)
        if (crystalType != null) {
            confidence += 0.3
        }
        
        // 3. Permittivit√§ts-Bereich (30%)
        if (crystalType != null) {
            val props = crystalProperties[crystalType]!!
            val permittivityMatch = (impedanceDelta.magnitude in 
                props.permittivity.start.magnitude..props.permittivity.endInclusive.magnitude)
            confidence += 0.3 * if (permittivityMatch) 1.0 else 0.0
        }
        
        return confidence.coerceIn(0.0, 1.0)
    }
}

data class CrystalProperties(
    val density: ClosedRange<Double>,
    val conductivity: Double,
    val permittivity: ClosedRange<Complex>
) 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/EMFADDevice.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import android.Manifest
import android.bluetooth.BluetoothDevice
import android.content.pm.PackageManager
import androidx.core.app.ActivityCompat

data class EMFADDevice(
    val bluetoothDevice: BluetoothDevice,
    val name: String = if (ActivityCompat.checkSelfPermission(
            this,
            Manifest.permission.BLUETOOTH_CONNECT
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        // TODO: Consider calling
        //    ActivityCompat#requestPermissions
        // here to request the missing permissions, and then overriding
        //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
        //                                          int[] grantResults)
        // to handle the case where the user grants the permission. See the documentation
        // for ActivityCompat#requestPermissions for more details.
        return
    }
    if (ActivityCompat.checkSelfPermission(
            this,
            Manifest.permission.BLUETOOTH_CONNECT
        ) != PackageManager.PERMISSION_GRANTED
    ) {
        // TODO: Consider calling
        //    ActivityCompat#requestPermissions
        // here to request the missing permissions, and then overriding
        //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
        //                                          int[] grantResults)
        // to handle the case where the user grants the permission. See the documentation
        // for ActivityCompat#requestPermissions for more details.
        return
    }
    bluetoothDevice.name ?: "EMFAD UG12DS",
    val address: String = bluetoothDevice.address,
    val isConnected: Boolean = false,
    val firmwareVersion: String = "",
    val serialNumber: String = "",
    val lastCalibrationDate: String = "",
    val measurementRanges: MeasurementRanges = MeasurementRanges()
) {
    data class MeasurementRanges(
        val electricFieldMin: Double = 0.0,    // V/m
        val electricFieldMax: Double = 2000.0,  // V/m
        val magneticFieldMin: Double = 0.0,     // ¬µT
        val magneticFieldMax: Double = 2000.0,  // ¬µT
        val frequencyMin: Double = 5.0,         // Hz
        val frequencyMax: Double = 100000.0     // Hz
    )

    companion object {
        fun isEMFADDevice(device: BluetoothDevice): Boolean {
            // √úberpr√ºft, ob es sich um ein EMFAD-Ger√§t handelt
            // Dies kann anhand des Ger√§tenamens oder der MAC-Adresse erfolgen
            return if (ActivityCompat.checkSelfPermission(
                    this,
                    Manifest.permission.BLUETOOTH_CONNECT
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return
            }
            device.name?.contains("EMFAD", ignoreCase = true) == true ||
                   device.address.startsWith("00:11:22") // Beispiel-MAC-Pr√§fix
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/EMFADMeasurement.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import java.util.*

data class EMFADMeasurement(
    val timestamp: Long,
    val electricField: Float, // V/m
    val magneticField: Float, // ¬µT
    val frequency: Float,     // Hz
    val mode: MeasurementMode,
    val batteryLevel: Int = 100 // Prozent
) {
    enum class MeasurementMode { SINGLE, CONTINUOUS, PEAK }

    companion object {
        fun fromRaw(input: String): EMFADMeasurement? {
            // Format: "timestamp,electricField,magneticField,frequency,mode,batteryLevel"
            return try {
                val parts = input.split(",")
                EMFADMeasurement(
                    timestamp = parts[0].toLong(),
                    electricField = parts[1].toFloat(),
                    magneticField = parts[2].toFloat(),
                    frequency = parts[3].toFloat(),
                    mode = MeasurementMode.valueOf(parts[4]),
                    batteryLevel = parts.getOrNull(5)?.toIntOrNull() ?: 100
                )
            } catch (e: Exception) {
                null
            }
        }
    }

    fun toRaw(): String {
        return "$timestamp,$electricField,$magneticField,$frequency,$mode,$batteryLevel"
    }

    fun convertToUnit(unit: ElectricFieldUnit): Float {
        return when (unit) {
            ElectricFieldUnit.V_PER_M -> electricField
            ElectricFieldUnit.KV_PER_M -> electricField / 1000
            ElectricFieldUnit.MV_PER_M -> electricField * 1000
        }
    }

    fun convertToUnit(unit: MagneticFieldUnit): Float {
        return when (unit) {
            MagneticFieldUnit.MICRO_TESLA -> magneticField
            MagneticFieldUnit.MILLI_GAUSS -> magneticField * 10
            MagneticFieldUnit.GAUSS -> magneticField * 0.01f
        }
    }
}

enum class ElectricFieldUnit {
    V_PER_M,
    KV_PER_M,
    MV_PER_M
}

enum class MagneticFieldUnit {
    MICRO_TESLA,
    MILLI_GAUSS,
    GAUSS
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/InclusionDetector.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.tan
import kotlin.math.PI

data class InclusionDetectionResult(
    val hasInclusion: Boolean,
    val inclusionType: InclusionType,
    val depth: Double,
    val size: Double,
    val confidence: Double,
    val properties: InclusionProperties
)

data class InclusionProperties(
    val conductivity: Double,
    val permittivity: Complex,
    val permeability: Double,
    val density: Double
)

enum class InclusionType {
    METAL,
    CRYSTAL,
    VOID,
    UNKNOWN
}

class InclusionDetector {
    companion object {
        private const val MU_0 = 4.0 * PI * 1e-7
        private const val EPSILON_0 = 8.854e-12
        private const val MIN_CONFIDENCE = 0.7
    }
    
    fun detectInclusion(
        measuredZ: Complex,
        frequency: Double,
        depth: Double,
        surroundingMaterial: MaterialProperties
    ): InclusionDetectionResult {
        // 1. Berechne effektive Impedanz
        val effectiveZ = calculateEffectiveImpedance(measuredZ, frequency, depth)
        
        // 2. Bestimme Einschlusstyp
        val (inclusionType, properties) = determineInclusionType(effectiveZ, frequency)
        
        // 3. Berechne Gr√∂√üe
        val size = estimateInclusionSize(effectiveZ, depth, properties)
        
        // 4. Berechne Zuverl√§ssigkeit
        val confidence = calculateConfidence(
            effectiveZ,
            surroundingMaterial,
            properties,
            depth
        )
        
        return InclusionDetectionResult(
            hasInclusion = confidence > MIN_CONFIDENCE,
            inclusionType = inclusionType,
            depth = depth,
            size = size,
            confidence = confidence,
            properties = properties
        )
    }
    
    private fun calculateEffectiveImpedance(
        measuredZ: Complex,
        frequency: Double,
        depth: Double
    ): Complex {
        val omega = 2.0 * PI * frequency
        val k = omega * sqrt(MU_0 * EPSILON_0)
        
        // Berechne effektive Impedanz nach Mehrschicht-Modell
        val Z1 = Complex(377.0, 0.0) // Luft-Impedanz
        val Z2 = measuredZ
        
        val k2d = k * depth
        val tanK2d = tan(k2d)
        
        return (Z1 + Complex(0.0, Z2.magnitude * tanK2d)) /
               (Complex(1.0, 0.0) + Complex(0.0, Z2.magnitude / Z1.magnitude * tanK2d))
    }
    
    private fun determineInclusionType(
        effectiveZ: Complex,
        frequency: Double
    ): Pair<InclusionType, InclusionProperties> {
        val omega = 2.0 * PI * frequency
        
        // Berechne Materialeigenschaften aus Impedanz
        val conductivity = calculateConductivity(effectiveZ, omega)
        val permittivity = calculatePermittivity(effectiveZ, omega)
        val permeability = calculatePermeability(effectiveZ, omega)
        val density = estimateDensity(conductivity, permittivity)
        
        val properties = InclusionProperties(
            conductivity = conductivity,
            permittivity = permittivity,
            permeability = permeability,
            density = density
        )
        
        val type = when {
            // Metall
            conductivity > 1e6 -> InclusionType.METAL
            
            // Kristall
            conductivity < 1e-10 && permittivity.magnitude > 5.0 -> InclusionType.CRYSTAL
            
            // Hohlraum
            conductivity < 1e-12 && permittivity.magnitude < 1.1 -> InclusionType.VOID
            
            else -> InclusionType.UNKNOWN
        }
        
        return Pair(type, properties)
    }
    
    private fun calculateConductivity(z: Complex, omega: Double): Double {
        return (z.imag * omega * EPSILON_0) / (z.real * z.real + z.imag * z.imag)
    }
    
    private fun calculatePermittivity(z: Complex, omega: Double): Complex {
        val sigma = calculateConductivity(z, omega)
        return Complex(
            z.real / (omega * MU_0),
            -sigma / (omega * EPSILON_0)
        )
    }
    
    private fun calculatePermeability(z: Complex, omega: Double): Double {
        return (z.real * z.real + z.imag * z.imag) / (omega * MU_0)
    }
    
    private fun estimateDensity(conductivity: Double, permittivity: Complex): Double {
        // Vereinfachte Sch√§tzung basierend auf Materialeigenschaften
        return when {
            conductivity > 1e6 -> 8.0..10.0 // Metall
            conductivity < 1e-10 && permittivity.magnitude > 5.0 -> 2.5..4.0 // Kristall
            else -> 1.0..2.0 // Hohlraum
        }.random()
    }
    
    private fun estimateInclusionSize(
        effectiveZ: Complex,
        depth: Double,
        properties: InclusionProperties
    ): Double {
        // Gr√∂√üenabsch√§tzung basierend auf Impedanz und Tiefe
        val impedanceRatio = effectiveZ.magnitude / 377.0 // Normierung auf Luft-Impedanz
        return depth * impedanceRatio * (properties.permittivity.magnitude / 10.0)
    }
    
    private fun calculateConfidence(
        effectiveZ: Complex,
        surroundingMaterial: MaterialProperties,
        inclusionProperties: InclusionProperties,
        depth: Double
    ): Double {
        var confidence = 0.0
        
        // 1. Impedanzkontrast (30%)
        val impedanceContrast = abs(effectiveZ.magnitude - 377.0) / 377.0
        confidence += 0.3 * impedanceContrast.coerceIn(0.0, 1.0)
        
        // 2. Materialkontrast (30%)
        val materialContrast = calculateMaterialContrast(
            surroundingMaterial,
            inclusionProperties
        )
        confidence += 0.3 * materialContrast
        
        // 3. Tiefenabh√§ngigkeit (20%)
        val depthConfidence = (1.0 - (depth / 10.0)).coerceIn(0.0, 1.0)
        confidence += 0.2 * depthConfidence
        
        // 4. Signalst√§rke (20%)
        val signalStrength = effectiveZ.magnitude / 1000.0
        confidence += 0.2 * signalStrength.coerceIn(0.0, 1.0)
        
        return confidence.coerceIn(0.0, 1.0)
    }
    
    private fun calculateMaterialContrast(
        surrounding: MaterialProperties,
        inclusion: InclusionProperties
    ): Double {
        val conductivityContrast = abs(
            log10(surrounding.conductivity) - log10(inclusion.conductivity)
        ).coerceIn(0.0, 10.0) / 10.0
        
        val permittivityContrast = abs(
            surrounding.permittivity.magnitude - inclusion.permittivity.magnitude
        ).coerceIn(0.0, 10.0) / 10.0
        
        return (conductivityContrast + permittivityContrast) / 2.0
    }
    
    private fun log10(x: Double): Double = kotlin.math.ln(x) / kotlin.math.ln(10.0)
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialAnalysis.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

data class MaterialAnalysis(
    val type: MaterialType,
    val confidence: Float,
    val timestamp: Long = System.currentTimeMillis()
)

enum class MaterialType {
    METAL,
    CAVITY,
    UNKNOWN
}

object MaterialAnalyzer {
    private const val METAL_THRESHOLD_MAGNETIC = 50.0 // ¬µT
    private const val CAVITY_THRESHOLD_ELECTRIC = 30.0 // V/m
    private const val CONFIDENCE_THRESHOLD = 0.7f

    fun analyzeMeasurement(measurement: EMFADMeasurement): MaterialAnalysis {
        val magneticField = measurement.magneticField
        val electricField = measurement.electricField
        
        // Metall-Erkennung basierend auf magnetischem Feld
        val metalConfidence = calculateMetalConfidence(magneticField)
        
        // Hohlraum-Erkennung basierend auf elektrischem Feld
        val cavityConfidence = calculateCavityConfidence(electricField)
        
        return when {
            metalConfidence > CONFIDENCE_THRESHOLD -> 
                MaterialAnalysis(MaterialType.METAL, metalConfidence)
            cavityConfidence > CONFIDENCE_THRESHOLD -> 
                MaterialAnalysis(MaterialType.CAVITY, cavityConfidence)
            else -> 
                MaterialAnalysis(MaterialType.UNKNOWN, 0f)
        }
    }

    private fun calculateMetalConfidence(magneticField: Double): Float {
        return (magneticField / METAL_THRESHOLD_MAGNETIC).toFloat().coerceIn(0f, 1f)
    }

    private fun calculateCavityConfidence(electricField: Double): Float {
        return (electricField / CAVITY_THRESHOLD_ELECTRIC).toFloat().coerceIn(0f, 1f)
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialAnalyzer.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

data class MaterialAnalysis(
    val type: MaterialType,
    val confidence: Float,
    val timestamp: Long = System.currentTimeMillis(),
    val trend: MaterialTrend? = null
)

enum class MaterialType {
    METAL,
    CAVITY,
    UNKNOWN
}

data class MaterialTrend(
    val direction: TrendDirection,
    val strength: Float,
    val lastChange: Long
)

enum class TrendDirection {
    INCREASING,
    DECREASING,
    STABLE
}

class MaterialAnalyzer(private val thresholds: AnalysisThresholds = AnalysisThresholds()) {
    private val recentAnalyses = mutableListOf<MaterialAnalysis>()

    fun analyzeMeasurement(measurement: EMFADMeasurement): MaterialAnalysis {
        val magneticField = measurement.magneticField
        val electricField = measurement.electricField
        
        val metalConfidence = calculateMetalConfidence(magneticField)
        val cavityConfidence = calculateCavityConfidence(electricField)
        
        val analysis = when {
            metalConfidence > thresholds.confidenceThreshold -> 
                MaterialAnalysis(MaterialType.METAL, metalConfidence)
            cavityConfidence > thresholds.confidenceThreshold -> 
                MaterialAnalysis(MaterialType.CAVITY, cavityConfidence)
            else -> 
                MaterialAnalysis(MaterialType.UNKNOWN, 0f)
        }

        // Trendanalyse
        recentAnalyses.add(analysis)
        if (recentAnalyses.size > thresholds.trendWindowSize) {
            recentAnalyses.removeAt(0)
        }
        
        val trend = analyzeTrend()
        return analysis.copy(trend = trend)
    }

    private fun calculateMetalConfidence(magneticField: Float): Float {
        return (magneticField / thresholds.magneticFieldMetalThreshold)
            .coerceIn(0f, 1f)
    }

    private fun calculateCavityConfidence(electricField: Float): Float {
        return (electricField / thresholds.electricFieldCavityThreshold)
            .coerceIn(0f, 1f)
    }

    private fun analyzeTrend(): MaterialTrend? {
        if (recentAnalyses.size < 2) return null

        val typeChanges = recentAnalyses.zipWithNext { a, b -> a.type != b.type }
        val lastChangeIndex = typeChanges.indexOfLast { it }
        
        if (lastChangeIndex == -1) {
            return MaterialTrend(
                direction = TrendDirection.STABLE,
                strength = 1f,
                lastChange = recentAnalyses.first().timestamp
            )
        }

        val confidenceChanges = recentAnalyses.zipWithNext { a, b -> 
            b.confidence - a.confidence 
        }
        
        val averageChange = confidenceChanges.average().toFloat()
        
        return MaterialTrend(
            direction = when {
                averageChange > 0.1f -> TrendDirection.INCREASING
                averageChange < -0.1f -> TrendDirection.DECREASING
                else -> TrendDirection.STABLE
            },
            strength = averageChange.absoluteValue.coerceIn(0f, 1f),
            lastChange = recentAnalyses[lastChangeIndex].timestamp
        )
    }

    fun getAnalysisHistory(): List<MaterialAnalysis> = recentAnalyses.toList()

    fun clearHistory() {
        recentAnalyses.clear()
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialCalibration.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.*

data class CalibrationData(
    val materialType: MaterialType,
    val depth: Float,
    val magneticField: Float,
    val electricField: Float,
    val frequency: Float,
    val abValue: Float
)

class MaterialCalibration {
    private val calibrationPoints = mutableListOf<CalibrationData>()
    private var calibrationFactors = mutableMapOf<MaterialType, CalibrationFactors>()
    
    data class CalibrationFactors(
        val magneticFactor: Float,
        val electricFactor: Float,
        val depthFactor: Float,
        val frequencyFactor: Float
    )
    
    fun addCalibrationPoint(data: CalibrationData) {
        calibrationPoints.add(data)
        updateCalibrationFactors()
    }
    
    fun removeCalibrationPoint(data: CalibrationData) {
        calibrationPoints.remove(data)
        updateCalibrationFactors()
    }
    
    fun getCalibrationFactors(materialType: MaterialType): CalibrationFactors? {
        return calibrationFactors[materialType]
    }
    
    private fun updateCalibrationFactors() {
        // Gruppiere Kalibrierungspunkte nach Materialtyp
        val groupedPoints = calibrationPoints.groupBy { it.materialType }
        
        // Berechne Kalibrierungsfaktoren f√ºr jeden Materialtyp
        groupedPoints.forEach { (materialType, points) ->
            if (points.size >= 2) {
                val factors = calculateFactors(points)
                calibrationFactors[materialType] = factors
            }
        }
    }
    
    private fun calculateFactors(points: List<CalibrationData>): CalibrationFactors {
        // Berechne Durchschnittswerte
        val avgMagnetic = points.map { it.magneticField }.average().toFloat()
        val avgElectric = points.map { it.electricField }.average().toFloat()
        val avgDepth = points.map { it.depth }.average().toFloat()
        val avgFrequency = points.map { it.frequency }.average().toFloat()
        
        // Berechne Standardabweichungen
        val stdMagnetic = calculateStandardDeviation(points.map { it.magneticField })
        val stdElectric = calculateStandardDeviation(points.map { it.electricField })
        val stdDepth = calculateStandardDeviation(points.map { it.depth })
        val stdFrequency = calculateStandardDeviation(points.map { it.frequency })
        
        // Berechne Kalibrierungsfaktoren
        return CalibrationFactors(
            magneticFactor = if (stdMagnetic > 0) 1f / stdMagnetic else 1f,
            electricFactor = if (stdElectric > 0) 1f / stdElectric else 1f,
            depthFactor = if (stdDepth > 0) 1f / stdDepth else 1f,
            frequencyFactor = if (stdFrequency > 0) 1f / stdFrequency else 1f
        )
    }
    
    private fun calculateStandardDeviation(values: List<Float>): Float {
        val mean = values.average()
        val variance = values.map { (it - mean) * (it - mean) }.average()
        return sqrt(variance).toFloat()
    }
    
    fun applyCalibration(
        measurement: EMFADMeasurement,
        materialType: MaterialType
    ): EMFADMeasurement {
        val factors = calibrationFactors[materialType] ?: return measurement
        
        return measurement.copy(
            magneticField = measurement.magneticField * factors.magneticFactor,
            electricField = measurement.electricField * factors.electricFactor,
            frequency = measurement.frequency * factors.frequencyFactor
        )
    }
    
    fun getCalibrationQuality(materialType: MaterialType): Float {
        val points = calibrationPoints.filter { it.materialType == materialType }
        if (points.size < 2) return 0f
        
        // Berechne die Qualit√§t basierend auf der Konsistenz der Messungen
        val magneticConsistency = calculateConsistency(points.map { it.magneticField })
        val electricConsistency = calculateConsistency(points.map { it.electricField })
        val depthConsistency = calculateConsistency(points.map { it.depth })
        
        return (magneticConsistency + electricConsistency + depthConsistency) / 3f
    }
    
    private fun calculateConsistency(values: List<Float>): Float {
        if (values.size < 2) return 0f
        
        val mean = values.average()
        val maxDeviation = values.map { abs(it - mean) }.maxOrNull() ?: 0f
        val range = values.maxOrNull()!! - values.minOrNull()!!
        
        return if (range > 0) 1f - (maxDeviation / range) else 1f
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialClassifier.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

data class MaterialSignature(
    val magneticField: Float,
    val electricField: Float,
    val type: MaterialType
)

enum class MaterialType {
    FERROUS_METAL,    // Eisenhaltige Metalle
    NON_FERROUS_METAL, // Nicht-eisenhaltige Metalle
    CAVITY,           // Hohlraum
    UNKNOWN
}

class MaterialClassifier(
    private var ferrousMagneticThreshold: Float = 80f,  // ¬µT
    private var nonFerrousElectricThreshold: Float = 30f,  // V/m
    private var nonFerrousMagneticThreshold: Float = 20f  // ¬µT
) {
    companion object {
        // Referenzsignaturen f√ºr verschiedene Materialien
        private val REFERENCE_SIGNATURES = mapOf(
            "Eisen" to MaterialSignature(120f, 10f, MaterialType.FERROUS_METAL),
            "Kupfer" to MaterialSignature(10f, 35f, MaterialType.NON_FERROUS_METAL),
            "Silber" to MaterialSignature(5f, 40f, MaterialType.NON_FERROUS_METAL),
            "Hohlraum" to MaterialSignature(2f, 15f, MaterialType.CAVITY)
        )
    }

    fun updateThresholds(
        ferrousMagnetic: Float? = null,
        nonFerrousElectric: Float? = null,
        nonFerrousMagnetic: Float? = null
    ) {
        ferrousMagnetic?.let { ferrousMagneticThreshold = it }
        nonFerrousElectric?.let { nonFerrousElectricThreshold = it }
        nonFerrousMagnetic?.let { nonFerrousMagneticThreshold = it }
    }

    fun classifyMaterial(measurement: EMFADMeasurement): MaterialAnalysis {
        val magneticField = measurement.magneticField
        val electricField = measurement.electricField
        
        // Basisklassifizierung
        val baseType = when {
            magneticField > ferrousMagneticThreshold -> MaterialType.FERROUS_METAL
            electricField > nonFerrousElectricThreshold && 
            magneticField < nonFerrousMagneticThreshold -> MaterialType.NON_FERROUS_METAL
            electricField < 20f && magneticField < 5f -> MaterialType.CAVITY
            else -> MaterialType.UNKNOWN
        }
        
        // Berechne Zuverl√§ssigkeit basierend auf √Ñhnlichkeit zu Referenzwerten
        val confidence = calculateConfidence(magneticField, electricField, baseType)
        
        return MaterialAnalysis(
            type = baseType,
            confidence = confidence,
            timestamp = measurement.timestamp
        )
    }

    private fun calculateConfidence(
        magneticField: Float,
        electricField: Float,
        type: MaterialType
    ): Float {
        // Finde die √§hnlichste Referenzsignatur
        val closestSignature = REFERENCE_SIGNATURES.values.minByOrNull { signature ->
            val magneticDiff = (signature.magneticField - magneticField).absoluteValue
            val electricDiff = (signature.electricField - electricField).absoluteValue
            magneticDiff + electricDiff
        } ?: return 0f

        // Berechne √Ñhnlichkeit (0-1)
        val magneticSimilarity = 1f - (closestSignature.magneticField - magneticField)
            .absoluteValue / closestSignature.magneticField
        val electricSimilarity = 1f - (closestSignature.electricField - electricField)
            .absoluteValue / closestSignature.electricField

        return (magneticSimilarity + electricSimilarity) / 2f
    }

    fun getMaterialDescription(type: MaterialType): String {
        return when (type) {
            MaterialType.FERROUS_METAL -> "Eisenhaltiges Metall (z.B. Eisen, Stahl)"
            MaterialType.NON_FERROUS_METAL -> "Nicht-eisenhaltiges Metall (z.B. Kupfer, Aluminium)"
            MaterialType.CAVITY -> "Hohlraum oder nicht-metallisches Material"
            MaterialType.UNKNOWN -> "Unbekanntes Material"
        }
    }

    fun getCurrentThresholds(): Map<String, Float> {
        return mapOf(
            "Ferrous Magnetic" to ferrousMagneticThreshold,
            "Non-Ferrous Electric" to nonFerrousElectricThreshold,
            "Non-Ferrous Magnetic" to nonFerrousMagneticThreshold
        )
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialDatabase.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

data class MaterialProperties(
    val name: String,
    val conductivity: Double,
    val permittivity: Complex,
    val permeability: Double,
    val density: Double,
    val type: MaterialType,
    val color: String,
    val typicalDepth: Double,
    val typicalSize: Double
)

enum class MaterialType {
    NATURAL_VEIN,
    ARTIFICIAL_STRUCTURE,
    CRYSTAL,
    UNKNOWN
}

class MaterialDatabase {
    companion object {
        private val MATERIALS = mapOf(
            // Nat√ºrliche Adern
            "gold_vein" to MaterialProperties(
                name = "Goldader",
                conductivity = 4.1e7,
                permittivity = Complex(1.0, 0.0),
                permeability = 1.0,
                density = 19.32,
                type = MaterialType.NATURAL_VEIN,
                color = "Gelb",
                typicalDepth = 2.5,
                typicalSize = 0.5
            ),
            "silver_vein" to MaterialProperties(
                name = "Silberader",
                conductivity = 6.3e7,
                permittivity = Complex(1.0, 0.0),
                permeability = 1.0,
                density = 10.49,
                type = MaterialType.NATURAL_VEIN,
                color = "Silber",
                typicalDepth = 2.0,
                typicalSize = 0.4
            ),
            "copper_vein" to MaterialProperties(
                name = "Kupferader",
                conductivity = 5.8e7,
                permittivity = Complex(1.0, 0.0),
                permeability = 1.0,
                density = 8.96,
                type = MaterialType.NATURAL_VEIN,
                color = "Rotbraun",
                typicalDepth = 1.8,
                typicalSize = 0.6
            ),
            "quartz_vein" to MaterialProperties(
                name = "Quarzader",
                conductivity = 1e-10,
                permittivity = Complex(4.5, 0.0),
                permeability = 1.0,
                density = 2.65,
                type = MaterialType.NATURAL_VEIN,
                color = "Wei√ü",
                typicalDepth = 1.5,
                typicalSize = 0.8
            ),
            "pyrite_vein" to MaterialProperties(
                name = "Pyritader",
                conductivity = 1e4,
                permittivity = Complex(5.0, 0.0),
                permeability = 1.0,
                density = 5.0,
                type = MaterialType.NATURAL_VEIN,
                color = "Gelb",
                typicalDepth = 1.2,
                typicalSize = 0.7
            ),
            
            // K√ºnstliche Strukturen
            "tunnel" to MaterialProperties(
                name = "Tunnel",
                conductivity = 1e-12,
                permittivity = Complex(1.0, 0.0),
                permeability = 1.0,
                density = 0.0,
                type = MaterialType.ARTIFICIAL_STRUCTURE,
                color = "Schwarz",
                typicalDepth = 5.0,
                typicalSize = 2.0
            ),
            "chamber" to MaterialProperties(
                name = "Kammer",
                conductivity = 1e-12,
                permittivity = Complex(1.0, 0.0),
                permeability = 1.0,
                density = 0.0,
                type = MaterialType.ARTIFICIAL_STRUCTURE,
                color = "Schwarz",
                typicalDepth = 3.0,
                typicalSize = 3.0
            ),
            "well" to MaterialProperties(
                name = "Brunnen",
                conductivity = 1e-12,
                permittivity = Complex(1.0, 0.0),
                permeability = 1.0,
                density = 0.0,
                type = MaterialType.ARTIFICIAL_STRUCTURE,
                color = "Schwarz",
                typicalDepth = 4.0,
                typicalSize = 1.0
            ),
            "foundation" to MaterialProperties(
                name = "Fundament",
                conductivity = 1e-6,
                permittivity = Complex(8.0, 0.0),
                permeability = 1.0,
                density = 2.4,
                type = MaterialType.ARTIFICIAL_STRUCTURE,
                color = "Grau",
                typicalDepth = 1.0,
                typicalSize = 2.0
            ),
            "wall" to MaterialProperties(
                name = "Mauer",
                conductivity = 1e-6,
                permittivity = Complex(8.0, 0.0),
                permeability = 1.0,
                density = 2.4,
                type = MaterialType.ARTIFICIAL_STRUCTURE,
                color = "Grau",
                typicalDepth = 0.5,
                typicalSize = 0.3
            ),
            
            // Kristalle
            "ruby" to MaterialProperties(
                name = "Rubin",
                conductivity = 1e-10,
                permittivity = Complex(9.5, 0.0),
                permeability = 1.0,
                density = 4.0,
                type = MaterialType.CRYSTAL,
                color = "Rot",
                typicalDepth = 1.5,
                typicalSize = 0.1
            ),
            "emerald" to MaterialProperties(
                name = "Smaragd",
                conductivity = 1e-10,
                permittivity = Complex(7.0, 0.0),
                permeability = 1.0,
                density = 2.75,
                type = MaterialType.CRYSTAL,
                color = "Gr√ºn",
                typicalDepth = 1.2,
                typicalSize = 0.1
            ),
            "diamond" to MaterialProperties(
                name = "Diamant",
                conductivity = 1e-13,
                permittivity = Complex(6.0, 0.0),
                permeability = 1.0,
                density = 3.55,
                type = MaterialType.CRYSTAL,
                color = "Wei√ü",
                typicalDepth = 2.0,
                typicalSize = 0.05
            ),
            "tourmaline" to MaterialProperties(
                name = "Turmalin",
                conductivity = 1e-9,
                permittivity = Complex(13.5, 0.0),
                permeability = 1.0,
                density = 3.15,
                type = MaterialType.CRYSTAL,
                color = "Schwarz",
                typicalDepth = 1.0,
                typicalSize = 0.2
            )
        )
    }
    
    fun getMaterial(key: String): MaterialProperties? = MATERIALS[key]
    
    fun getAllMaterials(): List<MaterialProperties> = MATERIALS.values.toList()
    
    fun getMaterialsByType(type: MaterialType): List<MaterialProperties> =
        MATERIALS.values.filter { it.type == type }
    
    fun findMatchingMaterial(
        conductivity: Double,
        permittivity: Complex,
        permeability: Double,
        density: Double
    ): MaterialProperties? {
        return MATERIALS.values.minByOrNull { material ->
            calculateMaterialDistance(
                material,
                conductivity,
                permittivity,
                permeability,
                density
            )
        }
    }
    
    private fun calculateMaterialDistance(
        material: MaterialProperties,
        conductivity: Double,
        permittivity: Complex,
        permeability: Double,
        density: Double
    ): Double {
        val conductivityDist = abs(log10(material.conductivity) - log10(conductivity))
        val permittivityDist = abs(material.permittivity.magnitude - permittivity.magnitude)
        val permeabilityDist = abs(material.permeability - permeability)
        val densityDist = abs(material.density - density)
        
        return sqrt(
            conductivityDist.pow(2) +
            permittivityDist.pow(2) +
            permeabilityDist.pow(2) +
            densityDist.pow(2)
        )
    }
    
    private fun log10(x: Double): Double = kotlin.math.ln(x) / kotlin.math.ln(10.0)
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialPhysicsAnalyzer.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.*

data class MaterialPhysicsAnalysis(
    val materialType: MaterialType,
    val depth: Float,  // Tiefe in mm
    val depthConfidence: Float,  // Zuverl√§ssigkeit der Tiefenberechnung
    val size: Float,   // Gr√∂√üe in mm
    val conductivity: Float,  // Leitf√§higkeit in S/m
    val confidence: Float,
    val magneticGradient: Float,  // nT/m
    val skinDepth: Float,  // mm
    val massEstimate: Float? = null,  // kg
    val volumeEstimate: Float? = null,  // m¬≥
    val layerAnalysis: List<LayerAnalysis> = emptyList(),
    val gemstoneDetection: GemstoneDetection? = null,  // Edelstein-Erkennung
    val veinOrStructureDetection: VeinOrStructureDetection? = null  // Ader- oder Struktur-Erkennung
)

data class LayerAnalysis(
    val depth: Float,  // mm
    val material: String,
    val conductivity: Float,  // S/m
    val magneticGradient: Float,  // nT/m
    val dielectricConstant: Float,
    val density: Float  // g/cm¬≥
)

class MaterialPhysicsAnalyzer {
    companion object {
        // Physikalische Konstanten
        private const val MU_0 = 4 * PI * 1e-7f  // Magnetische Feldkonstante
        private const val EPSILON_0 = 8.854e-12f  // Elektrische Feldkonstante
        private const val C = 299792458f  // Lichtgeschwindigkeit in m/s
        
        // Konversionsfaktoren
        private const val AB_TO_MICROVOLT = 0.48f  // 1 A/B-Einheit ‚âà 0.48 ¬µV/Hz
        private const val MAGNETIC_GRADIENT_FACTOR = 1.2f  // nT/m pro 1000 Einheiten
        
        // Referenzwerte f√ºr verschiedene Materialien
        private val MATERIAL_PROPERTIES = mapOf(
            MaterialType.FERROUS_METAL to MaterialProperties(
                relativePermeability = 1000f,
                conductivity = 1e7f,
                density = 7.87f,
                dielectricConstant = 1f,
                waveVelocity = C / sqrt(1000f)  // Wellengeschwindigkeit in ferromagnetischen Materialien
            ),
            MaterialType.NON_FERROUS_METAL to MaterialProperties(
                relativePermeability = 1f,
                conductivity = 5.8e7f,
                density = 19.3f,
                dielectricConstant = 1f,
                waveVelocity = C / sqrt(1f)
            ),
            MaterialType.CAVITY to MaterialProperties(
                relativePermeability = 1f,
                conductivity = 0f,
                density = 0f,
                dielectricConstant = 1f,
                waveVelocity = C
            )
        )
    }

    fun analyzeMaterial(
        magneticField: Double,
        electricField: Double,
        frequency: Double,
        phase: Double,
        depth: Double
    ): MaterialPhysicsAnalysis {
        // Berechne komplexe Impedanz
        val impedance = calculateImpedance(magneticField, electricField, phase)
        
        // Berechne Materialeigenschaften
        val conductivity = calculateConductivity(impedance, frequency)
        val permittivity = calculatePermittivity(impedance, frequency)
        val permeability = calculatePermeability(impedance, frequency)
        
        // Berechne magnetischen Gradienten
        val magneticGradient = calculateMagneticGradient(magneticField, depth)
        
        // Bestimme Anomalieform
        val anomalyShape = determineAnomalyShape(
            magneticField,
            electricField,
            phase,
            depth
        )
        
        // Berechne Aspektverh√§ltnis und Symmetrie
        val aspectRatio = calculateAspectRatio(magneticField, electricField, depth)
        val symmetry = calculateSymmetry(magneticField, electricField, phase)
        
        // Pr√ºfe auf Edelstein
        val gemstoneDetection = MaterialDatabase.detectGemstone(
            conductivity,
            permittivity,
            permeability,
            magneticGradient,
            anomalyShape
        )
        
        // Pr√ºfe auf Ader oder k√ºnstliche Struktur
        val veinOrStructureDetection = MaterialDatabase.detectVeinOrStructure(
            conductivity,
            permittivity,
            permeability,
            magneticGradient,
            anomalyShape,
            aspectRatio,
            symmetry,
            depth
        )
        
        // Finde passendes Material
        val material = MaterialDatabase.findMaterialByProperties(
            conductivity,
            permittivity,
            permeability
        )
        
        // Berechne Skintiefe
        val skinDepth = material?.let { 
            MaterialDatabase.calculateSkinDepth(frequency, it)
        } ?: calculateEstimatedSkinDepth(conductivity, frequency)
        
        // Bestimme Materialtyp
        val materialType = determineMaterialType(
            conductivity,
            permittivity,
            permeability,
            phase
        )
        
        // Berechne Volumen und Masse
        val (volume, mass) = calculateVolumeAndMass(
            depth,
            materialType,
            material?.density ?: estimateDensity(materialType)
        )
        
        // Analysiere Schichtung
        val layers = analyzeLayers(
            magneticField,
            electricField,
            frequency,
            phase,
            depth
        )
        
        return MaterialPhysicsAnalysis(
            materialType = materialType,
            depth = depth.toFloat(),
            depthConfidence = calculateDepthConfidence(
                magneticField,
                electricField,
                phase,
                depth
            ),
            size = volume.toFloat(),
            conductivity = conductivity.toFloat(),
            confidence = calculateReliability(
                magneticField,
                electricField,
                phase,
                materialType
            ),
            magneticGradient = magneticGradient.toFloat(),
            skinDepth = skinDepth.toFloat(),
            massEstimate = mass?.toFloat(),
            volumeEstimate = volume.toFloat(),
            layerAnalysis = layers,
            gemstoneDetection = gemstoneDetection,
            veinOrStructureDetection = veinOrStructureDetection
        )
    }
    
    private fun calculateImpedance(
        magneticField: Double,
        electricField: Double,
        phase: Double
    ): Complex {
        val magnitude = electricField / magneticField
        return Complex(
            magnitude * cos(phase),
            magnitude * sin(phase)
        )
    }
    
    private fun calculateConductivity(
        impedance: Complex,
        frequency: Double
    ): Double {
        val omega = 2 * PI * frequency
        val mu0 = 4 * PI * 1e-7
        
        // œÉ = œâ * Œº‚ÇÄ * |Z|¬≤ / (|Z|¬≤ + 2 * Re(Z) * |Z| + Re(Z)¬≤)
        val magnitudeSquared = impedance.real * impedance.real + impedance.imaginary * impedance.imaginary
        val denominator = magnitudeSquared + 2 * impedance.real * sqrt(magnitudeSquared) + impedance.real * impedance.real
        
        return omega * mu0 * magnitudeSquared / denominator
    }
    
    private fun calculatePermittivity(
        impedance: Complex,
        frequency: Double
    ): Double {
        val omega = 2 * PI * frequency
        val epsilon0 = 8.854e-12
        
        // Œµr = -Im(Z) / (œâ * Œµ‚ÇÄ * |Z|¬≤)
        val magnitudeSquared = impedance.real * impedance.real + impedance.imaginary * impedance.imaginary
        return -impedance.imaginary / (omega * epsilon0 * magnitudeSquared)
    }
    
    private fun calculatePermeability(
        impedance: Complex,
        frequency: Double
    ): Double {
        val omega = 2 * PI * frequency
        val mu0 = 4 * PI * 1e-7
        
        // Œºr = Re(Z) / (œâ * Œº‚ÇÄ)
        return impedance.real / (omega * mu0)
    }
    
    private fun determineMaterialType(
        conductivity: Double,
        permittivity: Double,
        permeability: Double,
        phase: Double
    ): MaterialType {
        return when {
            conductivity > 1e6 -> MaterialType.FERROUS_METAL
            conductivity > 1e4 -> MaterialType.NON_FERROUS_METAL
            permittivity > 50 -> MaterialType.WATER
            phase < -PI/4 -> MaterialType.CAVITY
            else -> MaterialType.UNKNOWN
        }
    }
    
    private fun calculateVolumeAndMass(
        depth: Double,
        materialType: MaterialType,
        density: Double
    ): Pair<Double, Double> {
        // Sch√§tze Volumen basierend auf Tiefe und Materialtyp
        val volume = when (materialType) {
            MaterialType.FERROUS_METAL -> depth * depth * depth * 0.5
            MaterialType.NON_FERROUS_METAL -> depth * depth * depth * 0.3
            MaterialType.CAVITY -> depth * depth * depth * 0.8
            MaterialType.WATER -> depth * depth * depth * 0.6
            else -> depth * depth * depth * 0.4
        }
        
        val mass = volume * density
        return Pair(volume, mass)
    }
    
    private fun analyzeLayers(
        magneticField: Double,
        electricField: Double,
        frequency: Double,
        phase: Double,
        depth: Double
    ): List<LayerAnalysis> {
        val layers = mutableListOf<LayerAnalysis>()
        
        // Analysiere Schichtung durch Fourier-Transformation
        val frequencies = listOf(frequency/2, frequency, frequency*2)
        val phases = frequencies.map { freq ->
            calculatePhaseAtFrequency(magneticField, electricField, freq)
        }
        
        // Erkenne Schichtgrenzen durch Phasenspr√ºnge
        for (i in 0 until phases.size - 1) {
            val phaseDiff = abs(phases[i+1] - phases[i])
            if (phaseDiff > PI/6) {
                val layerDepth = depth * (i+1) / frequencies.size
                val layerMaterial = determineMaterialType(
                    calculateConductivity(calculateImpedance(magneticField, electricField, phases[i]), frequencies[i]),
                    calculatePermittivity(calculateImpedance(magneticField, electricField, phases[i]), frequencies[i]),
                    calculatePermeability(calculateImpedance(magneticField, electricField, phases[i]), frequencies[i]),
                    phases[i]
                )
                
                layers.add(LayerAnalysis(
                    materialType = layerMaterial,
                    depth = layerDepth,
                    reliability = calculateLayerReliability(phaseDiff)
                ))
            }
        }
        
        return layers
    }
    
    private fun analyzeAnomalies(
        magneticField: Double,
        electricField: Double,
        frequency: Double,
        phase: Double,
        depth: Double
    ): List<AnomalyAnalysis> {
        val anomalies = mutableListOf<AnomalyAnalysis>()
        
        // Analysiere Anomalien durch Gradientenanalyse
        val magneticGradient = calculateMagneticGradient(magneticField, depth)
        val electricGradient = calculateElectricGradient(electricField, depth)
        
        // Erkenne Anomalien durch Gradienten√§nderungen
        if (abs(magneticGradient) > 0.1 || abs(electricGradient) > 0.1) {
            val anomalyType = when {
                magneticGradient > 0.1 && electricGradient < 0.1 -> AnomalyType.MAGNETIC
                electricGradient > 0.1 && magneticGradient < 0.1 -> AnomalyType.ELECTRIC
                else -> AnomalyType.COMBINED
            }
            
            anomalies.add(AnomalyAnalysis(
                type = anomalyType,
                intensity = max(abs(magneticGradient), abs(electricGradient)),
                depth = depth,
                reliability = calculateAnomalyReliability(magneticGradient, electricGradient)
            ))
        }
        
        return anomalies
    }
    
    private fun calculateMagneticGradient(magneticField: Double, depth: Double): Double {
        // Berechne magnetischen Gradienten
        return magneticField / (depth * depth)
    }
    
    private fun calculateElectricGradient(electricField: Double, depth: Double): Double {
        // Berechne elektrischen Gradienten
        return electricField / (depth * depth)
    }
    
    private fun calculatePhaseAtFrequency(
        magneticField: Double,
        electricField: Double,
        frequency: Double
    ): Double {
        // Berechne Phase bei gegebener Frequenz
        val impedance = calculateImpedance(magneticField, electricField, 0.0)
        return atan2(impedance.imaginary, impedance.real)
    }
    
    private fun calculateLayerReliability(phaseDiff: Double): Double {
        // Berechne Zuverl√§ssigkeit der Schichtanalyse
        return min(1.0, phaseDiff / (PI/2))
    }
    
    private fun calculateAnomalyReliability(
        magneticGradient: Double,
        electricGradient: Double
    ): Double {
        // Berechne Zuverl√§ssigkeit der Anomalieanalyse
        val maxGradient = max(abs(magneticGradient), abs(electricGradient))
        return min(1.0, maxGradient / 0.5)
    }
    
    private fun calculateEstimatedSkinDepth(conductivity: Double, frequency: Double): Double {
        val omega = 2 * PI * frequency
        val mu0 = 4 * PI * 1e-7
        return sqrt(2.0 / (omega * mu0 * conductivity))
    }
    
    private fun estimateDensity(materialType: MaterialType): Double {
        return when (materialType) {
            MaterialType.FERROUS_METAL -> 7.8
            MaterialType.NON_FERROUS_METAL -> 8.9
            MaterialType.CAVITY -> 0.0
            MaterialType.WATER -> 1.0
            else -> 2.5
        }
    }
    
    private fun calculateReliability(
        magneticField: Double,
        electricField: Double,
        phase: Double,
        materialType: MaterialType
    ): Double {
        // Berechne Gesamtzuverl√§ssigkeit der Analyse
        val fieldRatio = min(magneticField, electricField) / max(magneticField, electricField)
        val phaseReliability = 1.0 - abs(phase) / PI
        val typeReliability = when (materialType) {
            MaterialType.FERROUS_METAL -> 0.9
            MaterialType.NON_FERROUS_METAL -> 0.8
            MaterialType.CAVITY -> 0.7
            MaterialType.WATER -> 0.85
            else -> 0.5
        }
        
        return (fieldRatio + phaseReliability + typeReliability) / 3.0
    }
    
    private fun determineAnomalyShape(
        magneticField: Double,
        electricField: Double,
        phase: Double,
        depth: Double
    ): AnomalyShape {
        // Berechne Gradienten in verschiedenen Richtungen
        val horizontalGradient = calculateHorizontalGradient(magneticField, depth)
        val verticalGradient = calculateVerticalGradient(magneticField, depth)
        val phaseGradient = calculatePhaseGradient(phase, depth)
        
        // Bestimme Form basierend auf Gradienten
        return when {
            // Spalt: Starker vertikaler Gradient, schwacher horizontaler
            verticalGradient > 0.5 && horizontalGradient < 0.2 -> AnomalyShape.CREVICE
            
            // Punkt: Gleichm√§√üige Gradienten in alle Richtungen
            abs(verticalGradient - horizontalGradient) < 0.1 -> AnomalyShape.POINT
            
            // Ader: Starker horizontaler Gradient, schwacher vertikaler
            horizontalGradient > 0.5 && verticalGradient < 0.2 -> AnomalyShape.VEIN
            
            // Hohlraum: Starke Phasen√§nderung, schwache Gradienten
            abs(phaseGradient) > 0.5 && 
            verticalGradient < 0.2 && 
            horizontalGradient < 0.2 -> AnomalyShape.CAVITY
            
            // Schicht: Gleichm√§√üige Gradienten mit starker Phasen√§nderung
            abs(verticalGradient - horizontalGradient) < 0.2 && 
            abs(phaseGradient) > 0.3 -> AnomalyShape.LAYER
            
            // Unbekannt
            else -> AnomalyShape.UNKNOWN
        }
    }
    
    private fun calculateHorizontalGradient(magneticField: Double, depth: Double): Double {
        // Berechne horizontalen Gradienten
        return magneticField / (depth * depth)
    }
    
    private fun calculateVerticalGradient(magneticField: Double, depth: Double): Double {
        // Berechne vertikalen Gradienten
        return magneticField / (depth * depth * depth)
    }
    
    private fun calculatePhaseGradient(phase: Double, depth: Double): Double {
        // Berechne Phasengradienten
        return phase / depth
    }
    
    private fun calculateDepthConfidence(
        magneticField: Double,
        electricField: Double,
        phase: Double,
        depth: Double
    ): Float {
        // Berechne Zuverl√§ssigkeit der Tiefenbestimmung
        val fieldRatio = min(magneticField, electricField) / max(magneticField, electricField)
        val phaseReliability = 1.0 - abs(phase) / PI
        val depthReliability = when {
            depth < 100 -> 0.9  // Sehr zuverl√§ssig bei geringer Tiefe
            depth < 500 -> 0.8  // Gut bei mittlerer Tiefe
            depth < 1000 -> 0.6 // M√§√üig bei gr√∂√üerer Tiefe
            else -> 0.4         // Weniger zuverl√§ssig bei gro√üer Tiefe
        }
        
        return ((fieldRatio + phaseReliability + depthReliability) / 3.0).toFloat()
    }
    
    private fun calculateAspectRatio(
        magneticField: Double,
        electricField: Double,
        depth: Double
    ): Double {
        // Berechne das Aspektverh√§ltnis basierend auf den Gradienten
        val horizontalGradient = calculateHorizontalGradient(magneticField, depth)
        val verticalGradient = calculateVerticalGradient(magneticField, depth)
        
        return if (verticalGradient != 0.0) {
            horizontalGradient / verticalGradient
        } else {
            1.0
        }
    }
    
    private fun calculateSymmetry(
        magneticField: Double,
        electricField: Double,
        phase: Double
    ): Double {
        // Berechne die Symmetrie basierend auf den Feldverteilungen
        val fieldRatio = min(magneticField, electricField) / max(magneticField, electricField)
        val phaseSymmetry = 1.0 - abs(phase) / PI
        
        return (fieldRatio + phaseSymmetry) / 2.0
    }
}

private data class MaterialProperties(
    val relativePermeability: Float,
    val conductivity: Float,
    val density: Float,
    val dielectricConstant: Float,
    val waveVelocity: Float
) 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MaterialProperties.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

data class MaterialProperties(
    val name: String,
    val conductivity: Double,        // Leitf√§higkeit in S/m
    val relativePermittivity: Double, // Relative Permittivit√§t
    val relativePermeability: Double, // Relative Permeabilit√§t
    val density: Double,             // Dichte in g/cm¬≥
    val color: Int,                  // Materialfarbe f√ºr Visualisierung
    val reflectionCoefficient: Double, // Reflexionskoeffizient
    val isGemstone: Boolean = false,  // Ist es ein Edelstein?
    val gemstoneType: GemstoneType? = null, // Typ des Edelsteins, falls vorhanden
    val isNaturalVein: Boolean = false, // Ist es eine nat√ºrliche Ader?
    val veinType: VeinType? = null,  // Typ der Ader, falls vorhanden
    val isArtificialStructure: Boolean = false, // Ist es eine k√ºnstliche Struktur?
    val structureType: StructureType? = null // Typ der Struktur, falls vorhanden
)

enum class GemstoneType {
    DIAMOND,    // Diamant
    RUBY,       // Rubin
    EMERALD,    // Smaragd
    SAPPHIRE,   // Saphir
    TOPAZ,      // Topas
    AMETHYST,   // Amethyst
    TOURMALINE, // Turmalin
    GARNET      // Granat
}

enum class VeinType {
    GOLD_VEIN,      // Goldader
    SILVER_VEIN,    // Silberader
    COPPER_VEIN,    // Kupferader
    QUARTZ_VEIN,    // Quarzader
    PYRITE_VEIN,    // Pyritader
    MAGNETITE_VEIN  // Magnetitader
}

enum class StructureType {
    TUNNEL,         // Tunnel
    CHAMBER,        // Kammer
    WELL,           // Brunnen
    FOUNDATION,     // Fundament
    WALL,           // Mauer
    DRAINAGE        // Drainage
}

object MaterialDatabase {
    val materials = mapOf(
        "GOLD" to MaterialProperties(
            name = "Gold",
            conductivity = 4.1e7,
            relativePermittivity = 1.0,
            relativePermeability = 1.0,
            density = 19.3,
            color = 0xFFFFD700,
            reflectionCoefficient = 0.95
        ),
        "COPPER" to MaterialProperties(
            name = "Kupfer",
            conductivity = 5.8e7,
            relativePermittivity = 1.0,
            relativePermeability = 1.0,
            density = 8.96,
            color = 0xFFB87333,
            reflectionCoefficient = 0.90
        ),
        "ALUMINUM" to MaterialProperties(
            name = "Aluminium",
            conductivity = 3.5e7,
            relativePermittivity = 1.0,
            relativePermeability = 1.0,
            density = 2.70,
            color = 0xFFA9A9A9,
            reflectionCoefficient = 0.85
        ),
        "SILVER" to MaterialProperties(
            name = "Silber",
            conductivity = 6.3e7,
            relativePermittivity = 1.0,
            relativePermeability = 1.0,
            density = 10.49,
            color = 0xFFC0C0C0,
            reflectionCoefficient = 0.98
        ),
        "BASALT" to MaterialProperties(
            name = "Basalt",
            conductivity = 1e-4,
            relativePermittivity = 8.0,
            relativePermeability = 1.05,
            density = 3.0,
            color = 0xFF4A4A4A,
            reflectionCoefficient = 0.3
        ),
        "LIMESTONE" to MaterialProperties(
            name = "Kalkstein",
            conductivity = 1e-5,
            relativePermittivity = 6.0,
            relativePermeability = 1.0,
            density = 2.7,
            color = 0xFFE6E6E6,
            reflectionCoefficient = 0.2
        ),
        "CLAY" to MaterialProperties(
            name = "Ton",
            conductivity = 1e-2,
            relativePermittivity = 25.0,
            relativePermeability = 1.0,
            density = 2.0,
            color = 0xFF8B4513,
            reflectionCoefficient = 0.4
        ),
        "WOOD" to MaterialProperties(
            name = "Holz",
            conductivity = 1e-10,
            relativePermittivity = 4.0,
            relativePermeability = 1.0,
            density = 0.7,
            color = 0xFF8B4513,
            reflectionCoefficient = 0.1
        ),
        "WATER" to MaterialProperties(
            name = "Wasser",
            conductivity = 0.5,
            relativePermittivity = 80.0,
            relativePermeability = 1.0,
            density = 1.0,
            color = 0xFF4169E1,
            reflectionCoefficient = 0.5
        ),
        "DIAMOND" to MaterialProperties(
            name = "Diamant",
            conductivity = 0.0,
            relativePermittivity = 6.1,
            relativePermeability = 0.9999, // Diamagnetisch
            density = 3.5,
            color = 0xFFB9F2FF,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.DIAMOND
        ),
        "RUBY" to MaterialProperties(
            name = "Rubin",
            conductivity = 0.0,
            relativePermittivity = 9.4,
            relativePermeability = 0.9999,
            density = 4.0,
            color = 0xFFE0115F,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.RUBY
        ),
        "EMERALD" to MaterialProperties(
            name = "Smaragd",
            conductivity = 0.0,
            relativePermittivity = 7.25,
            relativePermeability = 0.9999,
            density = 2.85,
            color = 0xFF50C878,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.EMERALD
        ),
        "SAPPHIRE" to MaterialProperties(
            name = "Saphir",
            conductivity = 0.0,
            relativePermittivity = 9.4,
            relativePermeability = 0.9999,
            density = 4.0,
            color = 0xFF0F52BA,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.SAPPHIRE
        ),
        "TOPAZ" to MaterialProperties(
            name = "Topas",
            conductivity = 0.0,
            relativePermittivity = 9.0,
            relativePermeability = 0.9999,
            density = 3.5,
            color = 0xFFFFC87C,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.TOPAZ
        ),
        "AMETHYST" to MaterialProperties(
            name = "Amethyst",
            conductivity = 0.0,
            relativePermittivity = 4.5,
            relativePermeability = 0.9999,
            density = 2.6,
            color = 0xFF9966CC,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.AMETHYST
        ),
        "TOURMALINE" to MaterialProperties(
            name = "Turmalin",
            conductivity = 0.0,
            relativePermittivity = 13.0,
            relativePermeability = 0.9999,
            density = 3.1,
            color = 0xFF00FF7F,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.TOURMALINE
        ),
        "GARNET" to MaterialProperties(
            name = "Granat",
            conductivity = 0.0,
            relativePermittivity = 10.0,
            relativePermeability = 0.9999,
            density = 4.0,
            color = 0xFF733635,
            reflectionCoefficient = 0.2,
            isGemstone = true,
            gemstoneType = GemstoneType.GARNET
        ),
        "PYRITE" to MaterialProperties(
            name = "Pyrit",
            conductivity = 1e4,
            relativePermittivity = 5.0,
            relativePermeability = 1.0,
            density = 5.0,
            color = 0xFFB8860B,
            reflectionCoefficient = 0.4
        ),
        "MAGNETITE" to MaterialProperties(
            name = "Magnetit",
            conductivity = 1e3,
            relativePermittivity = 4.0,
            relativePermeability = 100.0,
            density = 5.2,
            color = 0xFF2F4F4F,
            reflectionCoefficient = 0.3
        ),
        "QUARTZ" to MaterialProperties(
            name = "Quarz",
            conductivity = 0.0,
            relativePermittivity = 4.5,
            relativePermeability = 0.9999,
            density = 2.65,
            color = 0xFFE6E6FA,
            reflectionCoefficient = 0.1
        )
    )
    
    fun findMaterialByProperties(
        conductivity: Double,
        permittivity: Double,
        permeability: Double
    ): MaterialProperties? {
        return materials.values.minByOrNull { material ->
            val conductivityDiff = Math.abs(Math.log10(material.conductivity + 1e-20) - Math.log10(conductivity + 1e-20))
            val permittivityDiff = Math.abs(material.relativePermittivity - permittivity)
            val permeabilityDiff = Math.abs(material.relativePermeability - permeability)
            
            conductivityDiff + permittivityDiff + permeabilityDiff
        }
    }
    
    fun calculateSkinDepth(frequency: Double, material: MaterialProperties): Double {
        val omega = 2 * Math.PI * frequency
        val mu = 4 * Math.PI * 1e-7 * material.relativePermeability
        return Math.sqrt(2.0 / (omega * mu * material.conductivity))
    }
    
    fun calculateImpedance(frequency: Double, material: MaterialProperties): Complex {
        val omega = 2 * Math.PI * frequency
        val mu = 4 * Math.PI * 1e-7 * material.relativePermeability
        val epsilon = 8.854e-12 * material.relativePermittivity
        
        val sigma = material.conductivity
        val j = Complex(0.0, 1.0)
        
        return Complex.sqrt(
            Complex(j.real * omega * mu, j.imaginary * omega * mu) /
            Complex(sigma, omega * epsilon)
        )
    }
    
    fun calculateReflectionCoefficient(
        material1: MaterialProperties,
        material2: MaterialProperties,
        frequency: Double
    ): Complex {
        val z1 = calculateImpedance(frequency, material1)
        val z2 = calculateImpedance(frequency, material2)
        
        return (z2 - z1) / (z2 + z1)
    }
    
    fun detectGemstone(
        conductivity: Double,
        permittivity: Double,
        permeability: Double,
        magneticGradient: Double,
        anomalyShape: AnomalyShape
    ): GemstoneDetection? {
        // Pr√ºfe auf Edelstein-Charakteristika
        if (conductivity < 1e-9 && 
            permittivity > 6.0 && 
            Math.abs(magneticGradient) < 0.1 &&
            (anomalyShape == AnomalyShape.CREVICE || 
             anomalyShape == AnomalyShape.POINT || 
             anomalyShape == AnomalyShape.VEIN)) {
            
            // Finde den passendsten Edelstein
            val gemstone = materials.values
                .filter { it.isGemstone }
                .minByOrNull { material ->
                    val permittivityDiff = Math.abs(material.relativePermittivity - permittivity)
                    val permeabilityDiff = Math.abs(material.relativePermeability - permeability)
                    permittivityDiff + permeabilityDiff
                }
            
            return gemstone?.let {
                GemstoneDetection(
                    gemstoneType = it.gemstoneType!!,
                    confidence = calculateGemstoneConfidence(
                        conductivity,
                        permittivity,
                        permeability,
                        magneticGradient,
                        anomalyShape,
                        it
                    ),
                    surroundingMinerals = detectSurroundingMinerals(
                        conductivity,
                        permittivity,
                        permeability
                    )
                )
            }
        }
        
        return null
    }
    
    private fun calculateGemstoneConfidence(
        conductivity: Double,
        permittivity: Double,
        permeability: Double,
        magneticGradient: Double,
        anomalyShape: AnomalyShape,
        gemstone: MaterialProperties
    ): Double {
        var confidence = 0.0
        
        // Leitf√§higkeit (sollte sehr niedrig sein)
        confidence += if (conductivity < 1e-9) 0.3 else 0.0
        
        // Permittivit√§t (sollte hoch sein)
        confidence += if (permittivity > 6.0) 0.2 else 0.0
        
        // Permeabilit√§t (sollte nahe 1 sein)
        confidence += if (Math.abs(permeability - 1.0) < 0.1) 0.2 else 0.0
        
        // Magnetischer Gradient (sollte niedrig sein)
        confidence += if (Math.abs(magneticGradient) < 0.1) 0.1 else 0.0
        
        // Anomalieform (sollte passend sein)
        confidence += when (anomalyShape) {
            AnomalyShape.CREVICE, AnomalyShape.POINT, AnomalyShape.VEIN -> 0.2
            else -> 0.0
        }
        
        return confidence
    }
    
    private fun detectSurroundingMinerals(
        conductivity: Double,
        permittivity: Double,
        permeability: Double
    ): List<MaterialProperties> {
        return materials.values
            .filter { !it.isGemstone }
            .filter { material ->
                val conductivityMatch = Math.abs(Math.log10(material.conductivity + 1e-20) - Math.log10(conductivity + 1e-20)) < 2.0
                val permittivityMatch = Math.abs(material.relativePermittivity - permittivity) < 5.0
                val permeabilityMatch = Math.abs(material.relativePermeability - permeability) < 10.0
                
                conductivityMatch && (permittivityMatch || permeabilityMatch)
            }
    }
}

data class Complex(
    val real: Double,
    val imaginary: Double
) {
    operator fun plus(other: Complex) = Complex(
        real + other.real,
        imaginary + other.imaginary
    )
    
    operator fun minus(other: Complex) = Complex(
        real - other.real,
        imaginary - other.imaginary
    )
    
    operator fun times(other: Complex) = Complex(
        real * other.real - imaginary * other.imaginary,
        real * other.imaginary + imaginary * other.real
    )
    
    operator fun div(other: Complex): Complex {
        val denominator = other.real * other.real + other.imaginary * other.imaginary
        return Complex(
            (real * other.real + imaginary * other.imaginary) / denominator,
            (imaginary * other.real - real * other.imaginary) / denominator
        )
    }
    
    companion object {
        fun sqrt(z: Complex): Complex {
            val r = Math.sqrt(z.real * z.real + z.imaginary * z.imaginary)
            val theta = Math.atan2(z.imaginary, z.real)
            val sqrtR = Math.sqrt(r)
            val halfTheta = theta / 2
            
            return Complex(
                sqrtR * Math.cos(halfTheta),
                sqrtR * Math.sin(halfTheta)
            )
        }
    }
}

data class GemstoneDetection(
    val gemstoneType: GemstoneType,
    val confidence: Double,
    val surroundingMinerals: List<MaterialProperties>
)

enum class AnomalyShape {
    CREVICE,    // Spalt
    POINT,      // Punkt
    VEIN,       // Ader
    CAVITY,     // Hohlraum
    LAYER,      // Schicht
    UNKNOWN     // Unbekannt
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MeasurementMode.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.PI
import kotlin.math.sqrt

enum class MeasurementMode {
    BA_VERTICAL,
    AB_HORIZONTAL,
    ANTENNA_A,
    DEPTH_PRO
}

data class MeasurementConfig(
    val mode: MeasurementMode,
    val frequency: Double,
    val antennaDistance: Double,
    val calibrationFactor: Double = 1.0,
    val isCalibrated: Boolean = false
)

data class MeasurementResult(
    val impedance: Complex,
    val depth: Double,
    val confidence: Double,
    val mode: MeasurementMode,
    val timestamp: Long = System.currentTimeMillis()
)

class MeasurementController {
    companion object {
        private const val MU_0 = 4.0 * PI * 1e-7
        private const val EPSILON_0 = 8.854e-12
        
        // Standardkonfigurationen f√ºr jeden Modus
        private val DEFAULT_CONFIGS = mapOf(
            MeasurementMode.BA_VERTICAL to MeasurementConfig(
                mode = MeasurementMode.BA_VERTICAL,
                frequency = 1000.0, // 1 kHz
                antennaDistance = 1.0 // 1m
            ),
            MeasurementMode.AB_HORIZONTAL to MeasurementConfig(
                mode = MeasurementMode.AB_HORIZONTAL,
                frequency = 2000.0, // 2 kHz
                antennaDistance = 0.5 // 0.5m
            ),
            MeasurementMode.ANTENNA_A to MeasurementConfig(
                mode = MeasurementMode.ANTENNA_A,
                frequency = 500.0, // 500 Hz
                antennaDistance = 0.0 // Einzelantenne
            ),
            MeasurementMode.DEPTH_PRO to MeasurementConfig(
                mode = MeasurementMode.DEPTH_PRO,
                frequency = 5000.0, // 5 kHz
                antennaDistance = 1.5 // 1.5m
            )
        )
    }
    
    private var currentConfig: MeasurementConfig = DEFAULT_CONFIGS[MeasurementMode.BA_VERTICAL]!!
    
    fun setMode(mode: MeasurementMode) {
        currentConfig = DEFAULT_CONFIGS[mode] ?: throw IllegalArgumentException("Ung√ºltiger Messmodus")
    }
    
    fun updateConfig(config: MeasurementConfig) {
        currentConfig = config
    }
    
    fun measure(): MeasurementResult {
        // Simuliere Messung basierend auf aktuellem Modus
        val (impedance, depth) = when (currentConfig.mode) {
            MeasurementMode.BA_VERTICAL -> measureVertical()
            MeasurementMode.AB_HORIZONTAL -> measureHorizontal()
            MeasurementMode.ANTENNA_A -> measureSingleAntenna()
            MeasurementMode.DEPTH_PRO -> measureDepthPro()
        }
        
        return MeasurementResult(
            impedance = impedance,
            depth = depth,
            confidence = calculateConfidence(impedance, depth),
            mode = currentConfig.mode
        )
    }
    
    private fun measureVertical(): Pair<Complex, Double> {
        // B-A Vertikal Messung
        val omega = 2.0 * PI * currentConfig.frequency
        val k = omega * sqrt(MU_0 * EPSILON_0)
        
        // Simuliere vertikale Impedanz
        val z = Complex(
            real = 377.0 * (1.0 + 0.1 * kotlin.math.sin(k * currentConfig.antennaDistance)),
            imag = 377.0 * 0.1 * kotlin.math.cos(k * currentConfig.antennaDistance)
        )
        
        // Sch√§tze Tiefe basierend auf Impedanz
        val depth = estimateDepth(z, currentConfig.frequency)
        
        return Pair(z, depth)
    }
    
    private fun measureHorizontal(): Pair<Complex, Double> {
        // A-B Horizontal Messung
        val omega = 2.0 * PI * currentConfig.frequency
        val k = omega * sqrt(MU_0 * EPSILON_0)
        
        // Simuliere horizontale Impedanz
        val z = Complex(
            real = 377.0 * (1.0 + 0.2 * kotlin.math.cos(k * currentConfig.antennaDistance)),
            imag = 377.0 * 0.2 * kotlin.math.sin(k * currentConfig.antennaDistance)
        )
        
        // Sch√§tze Tiefe basierend auf Impedanz
        val depth = estimateDepth(z, currentConfig.frequency)
        
        return Pair(z, depth)
    }
    
    private fun measureSingleAntenna(): Pair<Complex, Double> {
        // Antenne A Messung
        val omega = 2.0 * PI * currentConfig.frequency
        
        // Simuliere Einzelantennen-Impedanz
        val z = Complex(
            real = 377.0 * (1.0 + 0.05 * kotlin.math.sin(omega * 0.001)),
            imag = 377.0 * 0.05 * kotlin.math.cos(omega * 0.001)
        )
        
        // Sch√§tze Tiefe basierend auf Impedanz
        val depth = estimateDepth(z, currentConfig.frequency)
        
        return Pair(z, depth)
    }
    
    private fun measureDepthPro(): Pair<Complex, Double> {
        // Tiefe Pro Messung (Hz/Hx-Methode)
        val omega = 2.0 * PI * currentConfig.frequency
        val k = omega * sqrt(MU_0 * EPSILON_0)
        
        // Simuliere Hz/Hx-Messung
        val hz = Complex(
            real = kotlin.math.sin(k * currentConfig.antennaDistance),
            imag = kotlin.math.cos(k * currentConfig.antennaDistance)
        )
        
        val hx = Complex(
            real = kotlin.math.cos(k * currentConfig.antennaDistance),
            imag = kotlin.math.sin(k * currentConfig.antennaDistance)
        )
        
        val z = hz / hx * 377.0
        
        // Pr√§zise Tiefensch√§tzung f√ºr Tiefe Pro
        val depth = estimateDepthPro(z, hz, hx)
        
        return Pair(z, depth)
    }
    
    private fun estimateDepth(z: Complex, frequency: Double): Double {
        // Vereinfachte Tiefensch√§tzung basierend auf Impedanz und Frequenz
        val omega = 2.0 * PI * frequency
        val k = omega * sqrt(MU_0 * EPSILON_0)
        
        return kotlin.math.abs(z.imag) / (k * z.real)
    }
    
    private fun estimateDepthPro(z: Complex, hz: Complex, hx: Complex): Double {
        // Pr√§zise Tiefensch√§tzung nach Hz/Hx-Methode
        val phaseDiff = kotlin.math.atan2(hz.imag, hz.real) - kotlin.math.atan2(hx.imag, hx.real)
        val k = 2.0 * PI * currentConfig.frequency * sqrt(MU_0 * EPSILON_0)
        
        return phaseDiff / k
    }
    
    private fun calculateConfidence(z: Complex, depth: Double): Double {
        var confidence = 0.0
        
        // 1. Signalst√§rke (30%)
        val signalStrength = z.magnitude / 377.0
        confidence += 0.3 * signalStrength.coerceIn(0.0, 1.0)
        
        // 2. Tiefenabh√§ngigkeit (30%)
        val depthConfidence = when (currentConfig.mode) {
            MeasurementMode.BA_VERTICAL -> (1.0 - (depth / 5.0)).coerceIn(0.0, 1.0)
            MeasurementMode.AB_HORIZONTAL -> (1.0 - (depth / 3.0)).coerceIn(0.0, 1.0)
            MeasurementMode.ANTENNA_A -> (1.0 - (depth / 2.0)).coerceIn(0.0, 1.0)
            MeasurementMode.DEPTH_PRO -> (1.0 - (depth / 10.0)).coerceIn(0.0, 1.0)
        }
        confidence += 0.3 * depthConfidence
        
        // 3. Kalibrierungsqualit√§t (20%)
        val calibrationConfidence = if (currentConfig.isCalibrated) 1.0 else 0.5
        confidence += 0.2 * calibrationConfidence
        
        // 4. Frequenzabh√§ngigkeit (20%)
        val frequencyConfidence = (currentConfig.frequency / 5000.0).coerceIn(0.0, 1.0)
        confidence += 0.2 * frequencyConfidence
        
        return confidence.coerceIn(0.0, 1.0)
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MeasurementSession.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import java.util.*

data class MeasurementSession(
    val id: String = UUID.randomUUID().toString(),
    val deviceId: String,
    val location: String,
    val notes: String?,
    val type: SessionType,
    val startTime: Long = System.currentTimeMillis(),
    val endTime: Long? = null,
    val measurements: MutableList<EMFADMeasurement> = mutableListOf(),
    val tags: Set<String> = emptySet()
) {
    enum class SessionType { STANDARD, COMPLIANCE, RESEARCH }

    val duration: Long
        get() = (endTime ?: System.currentTimeMillis()) - startTime

    val averageElectricField: Float
        get() = measurements.map { it.electricField }.average().toFloat()

    val peakElectricField: Float
        get() = measurements.maxOfOrNull { it.electricField } ?: 0f

    val averageMagneticField: Float
        get() = measurements.map { it.magneticField }.average().toFloat()

    val peakMagneticField: Float
        get() = measurements.maxOfOrNull { it.magneticField } ?: 0f

    fun addMeasurement(measurement: EMFADMeasurement) {
        measurements.add(measurement)
    }

    fun end() {
        endTime = System.currentTimeMillis()
    }

    fun exportToCsv(): String {
        val header = "timestamp,electricField,magneticField,frequency,mode,batteryLevel"
        val body = measurements.joinToString("\n") { it.toRaw() }
        return "$header\n$body"
    }

    fun getStatistics(): Map<String, Float> {
        return mapOf(
            "Durchschnittliches E-Feld" to averageElectricField,
            "Spitzenwert E-Feld" to peakElectricField,
            "Durchschnittliches M-Feld" to averageMagneticField,
            "Spitzenwert M-Feld" to peakMagneticField,
            "Messdauer" to (duration / 1000f),
            "Anzahl Messungen" to measurements.size.toFloat()
        )
    }

    fun addTag(tag: String) {
        (tags as MutableSet).add(tag)
    }

    fun removeTag(tag: String) {
        (tags as MutableSet).remove(tag)
    }

    fun hasTag(tag: String): Boolean {
        return tags.contains(tag)
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/models/MetalAnalyzer.kt
# TYP: .kt
================================================================================
package com.emfad.app.models

import kotlin.math.sqrt
import kotlin.math.PI

data class MetalAnalysisResult(
    val metalType: MetalType,
    val conductivity: Double,
    val skinDepth: Double,
    val confidence: Double,
    val properties: MetalProperties
)

data class MetalProperties(
    val conductivity: Double,
    val permeability: Double,
    val density: Double,
    val color: String
)

enum class MetalType {
    GOLD,
    SILVER,
    COPPER,
    BRONZE,
    UNKNOWN
}

class MetalAnalyzer {
    companion object {
        private const val MU_0 = 4.0 * PI * 1e-7
        private const val MIN_CONFIDENCE = 0.7
        
        private val METAL_PROPERTIES = mapOf(
            MetalType.GOLD to MetalProperties(
                conductivity = 4.1e7,
                permeability = 1.0,
                density = 19.32,
                color = "Gelb"
            ),
            MetalType.SILVER to MetalProperties(
                conductivity = 6.3e7,
                permeability = 1.0,
                density = 10.49,
                color = "Silber"
            ),
            MetalType.COPPER to MetalProperties(
                conductivity = 5.8e7,
                permeability = 1.0,
                density = 8.96,
                color = "Rotbraun"
            ),
            MetalType.BRONZE to MetalProperties(
                conductivity = 1.0e6,
                permeability = 1.0,
                density = 8.73,
                color = "Bronze"
            )
        )
    }
    
    fun analyzeMetal(
        impedanceCurve: List<Pair<Double, Complex>>,
        frequency: Double
    ): MetalAnalysisResult {
        // 1. Berechne Skin-Tiefen
        val skinDepths = impedanceCurve.map { (freq, z) ->
            calculateSkinDepth(freq, z)
        }
        
        // 2. Bestimme Metalltyp
        val (metalType, properties) = determineMetalType(impedanceCurve, skinDepths)
        
        // 3. Berechne Zuverl√§ssigkeit
        val confidence = calculateConfidence(impedanceCurve, skinDepths, properties)
        
        return MetalAnalysisResult(
            metalType = metalType,
            conductivity = properties.conductivity,
            skinDepth = skinDepths.first(),
            confidence = confidence,
            properties = properties
        )
    }
    
    private fun calculateSkinDepth(frequency: Double, impedance: Complex): Double {
        val omega = 2.0 * PI * frequency
        val conductivity = calculateConductivity(impedance, omega)
        return sqrt(2.0 / (MU_0 * conductivity * omega))
    }
    
    private fun calculateConductivity(z: Complex, omega: Double): Double {
        return (z.imag * omega * 8.854e-12) / (z.real * z.real + z.imag * z.imag)
    }
    
    private fun determineMetalType(
        impedanceCurve: List<Pair<Double, Complex>>,
        skinDepths: List<Double>
    ): Pair<MetalType, MetalProperties> {
        // Berechne durchschnittliche Leitf√§higkeit
        val avgConductivity = impedanceCurve.map { (freq, z) ->
            calculateConductivity(z, 2.0 * PI * freq)
        }.average()
        
        // Bestimme Metalltyp basierend auf Leitf√§higkeit
        val type = when {
            avgConductivity > 5.0e7 -> MetalType.SILVER
            avgConductivity > 4.0e7 -> MetalType.GOLD
            avgConductivity > 5.0e6 -> MetalType.COPPER
            avgConductivity > 1.0e6 -> MetalType.BRONZE
            else -> MetalType.UNKNOWN
        }
        
        return Pair(type, METAL_PROPERTIES[type] ?: METAL_PROPERTIES[MetalType.UNKNOWN]!!)
    }
    
    private fun calculateConfidence(
        impedanceCurve: List<Pair<Double, Complex>>,
        skinDepths: List<Double>,
        properties: MetalProperties
    ): Double {
        var confidence = 0.0
        
        // 1. Frequenzabh√§ngigkeit (30%)
        val frequencyConfidence = calculateFrequencyConfidence(impedanceCurve)
        confidence += 0.3 * frequencyConfidence
        
        // 2. Skin-Effekt (30%)
        val skinEffectConfidence = calculateSkinEffectConfidence(skinDepths)
        confidence += 0.3 * skinEffectConfidence
        
        // 3. Leitf√§higkeits√ºbereinstimmung (20%)
        val conductivityConfidence = calculateConductivityConfidence(
            impedanceCurve,
            properties.conductivity
        )
        confidence += 0.2 * conductivityConfidence
        
        // 4. Impedanzverlauf (20%)
        val impedanceConfidence = calculateImpedanceConfidence(impedanceCurve)
        confidence += 0.2 * impedanceConfidence
        
        return confidence.coerceIn(0.0, 1.0)
    }
    
    private fun calculateFrequencyConfidence(
        impedanceCurve: List<Pair<Double, Complex>>
    ): Double {
        // Pr√ºfe auf erwartetes Frequenzverhalten
        val frequencies = impedanceCurve.map { it.first }
        val impedances = impedanceCurve.map { it.second.magnitude }
        
        // Berechne Korrelation zwischen Frequenz und Impedanz
        val correlation = calculateCorrelation(frequencies, impedances)
        
        return (correlation + 1.0) / 2.0 // Normalisiere auf [0,1]
    }
    
    private fun calculateSkinEffectConfidence(skinDepths: List<Double>): Double {
        // Pr√ºfe auf erwartetes Skin-Effekt-Verhalten
        val expectedRatio = sqrt(skinDepths.first() / skinDepths.last())
        val actualRatio = skinDepths.first() / skinDepths.last()
        
        return (1.0 - abs(expectedRatio - actualRatio) / expectedRatio)
            .coerceIn(0.0, 1.0)
    }
    
    private fun calculateConductivityConfidence(
        impedanceCurve: List<Pair<Double, Complex>>,
        expectedConductivity: Double
    ): Double {
        val avgConductivity = impedanceCurve.map { (freq, z) ->
            calculateConductivity(z, 2.0 * PI * freq)
        }.average()
        
        val ratio = minOf(avgConductivity, expectedConductivity) /
                   maxOf(avgConductivity, expectedConductivity)
        
        return ratio.coerceIn(0.0, 1.0)
    }
    
    private fun calculateImpedanceConfidence(
        impedanceCurve: List<Pair<Double, Complex>>
    ): Double {
        // Pr√ºfe auf erwarteten Impedanzverlauf
        val impedances = impedanceCurve.map { it.second.magnitude }
        val mean = impedances.average()
        val stdDev = sqrt(impedances.map { (it - mean).pow(2) }.average())
        
        return (1.0 - stdDev / mean).coerceIn(0.0, 1.0)
    }
    
    private fun calculateCorrelation(x: List<Double>, y: List<Double>): Double {
        val n = x.size
        val meanX = x.average()
        val meanY = y.average()
        
        val numerator = x.zip(y).sumOf { (xi, yi) ->
            (xi - meanX) * (yi - meanY)
        }
        
        val denominator = sqrt(
            x.sumOf { (it - meanX).pow(2) } *
            y.sumOf { (it - meanY).pow(2) }
        )
        
        return numerator / denominator
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/navigation/AppNavigation.kt
# TYP: .kt
================================================================================
package com.emfad.app.navigation

import androidx.compose.runtime.Composable
import androidx.navigation.NavHostController
import androidx.navigation.compose.NavHost
import androidx.navigation.compose.composable
import com.emfad.app.ui.MainScreen
import com.emfad.app.ui.SettingsScreen

sealed class Screen(val route: String) {
    object Main : Screen("main")
    object Settings : Screen("settings")
}

@Composable
fun AppNavigation(
    navController: NavHostController
) {
    NavHost(
        navController = navController,
        startDestination = Screen.Main.route
    ) {
        composable(Screen.Main.route) {
            MainScreen(
                onNavigateToSettings = {
                    navController.navigate(Screen.Settings.route)
                }
            )
        }
        
        composable(Screen.Settings.route) {
            SettingsScreen(
                onNavigateBack = {
                    navController.popBackStack()
                }
            )
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/services/BluetoothService.kt
# TYP: .kt
================================================================================
package com.emfad.app.services

import android.Manifest
import android.bluetooth.BluetoothAdapter
import android.bluetooth.BluetoothDevice
import android.bluetooth.BluetoothManager
import android.content.Context
import android.content.pm.PackageManager
import android.util.Log
import androidx.core.app.ActivityCompat
import com.emfad.app.models.EMFADDevice
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import java.util.*

class BluetoothService(private val context: Context) {
    private val TAG = "BluetoothService"
    private val SPP_UUID = UUID.fromString("00001101-0000-1000-8000-00805F9B34FB")
    
    private val bluetoothManager = context.getSystemService(Context.BLUETOOTH_SERVICE) as BluetoothManager
    private val bluetoothAdapter: BluetoothAdapter? = bluetoothManager.adapter
    
    private val _discoveredDevices = MutableStateFlow<List<EMFADDevice>>(emptyList())
    val discoveredDevices: StateFlow<List<EMFADDevice>> = _discoveredDevices
    
    private val _connectionState = MutableStateFlow<ConnectionState>(ConnectionState.DISCONNECTED)
    val connectionState: StateFlow<ConnectionState> = _connectionState
    
    private val _receivedData = MutableStateFlow<String>("")
    val receivedData: StateFlow<String> = _receivedData

    sealed class ConnectionState {
        object CONNECTED : ConnectionState()
        object DISCONNECTED : ConnectionState()
        object CONNECTING : ConnectionState()
        data class ERROR(val message: String) : ConnectionState()
    }

    fun startDiscovery() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.BLUETOOTH_SCAN
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return
        }
        if (bluetoothAdapter?.isDiscovering == true) {
            if (ActivityCompat.checkSelfPermission(
                    this,
                    Manifest.permission.BLUETOOTH_SCAN
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return
            }
            bluetoothAdapter.cancelDiscovery()
        }

        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.BLUETOOTH_SCAN
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return
        }
        bluetoothAdapter?.startDiscovery()
    }

    fun stopDiscovery() {
        if (ActivityCompat.checkSelfPermission(
                this,
                Manifest.permission.BLUETOOTH_SCAN
            ) != PackageManager.PERMISSION_GRANTED
        ) {
            // TODO: Consider calling
            //    ActivityCompat#requestPermissions
            // here to request the missing permissions, and then overriding
            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
            //                                          int[] grantResults)
            // to handle the case where the user grants the permission. See the documentation
            // for ActivityCompat#requestPermissions for more details.
            return
        }
        bluetoothAdapter?.cancelDiscovery()
    }

    fun onDeviceFound(device: BluetoothDevice) {
        if (EMFADDevice.isEMFADDevice(device)) {
            val emfadDevice = EMFADDevice(bluetoothDevice = device)
            val currentDevices = _discoveredDevices.value.toMutableList()
            if (!currentDevices.any { it.address == device.address }) {
                currentDevices.add(emfadDevice)
                _discoveredDevices.value = currentDevices
            }
        }
    }

    fun connectToDevice(device: EMFADDevice) {
        _connectionState.value = ConnectionState.CONNECTING
        
        try {
            val socket = if (ActivityCompat.checkSelfPermission(
                    this,
                    Manifest.permission.BLUETOOTH_CONNECT
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return
            }
                device.bluetoothDevice.createRfcommSocketToServiceRecord(SPP_UUID)
            if (ActivityCompat.checkSelfPermission(
                    this,
                    Manifest.permission.BLUETOOTH_CONNECT
                ) != PackageManager.PERMISSION_GRANTED
            ) {
                // TODO: Consider calling
                //    ActivityCompat#requestPermissions
                // here to request the missing permissions, and then overriding
                //   public void onRequestPermissionsResult(int requestCode, String[] permissions,
                //                                          int[] grantResults)
                // to handle the case where the user grants the permission. See the documentation
                // for ActivityCompat#requestPermissions for more details.
                return
            }
            socket.connect()
            _connectionState.value = ConnectionState.CONNECTED
            startListening(socket)
        } catch (e: Exception) {
            Log.e(TAG, "Verbindungsfehler: ${e.message}")
            _connectionState.value = ConnectionState.ERROR(e.message ?: "Unbekannter Fehler")
        }
    }

    private fun startListening(socket: android.bluetooth.BluetoothSocket) {
        Thread {
            val buffer = ByteArray(1024)
            while (_connectionState.value == ConnectionState.CONNECTED) {
                try {
                    val bytes = socket.inputStream.read(buffer)
                    if (bytes > 0) {
                        val data = String(buffer, 0, bytes)
                        _receivedData.value = data
                    }
                } catch (e: Exception) {
                    Log.e(TAG, "Lesefehler: ${e.message}")
                    _connectionState.value = ConnectionState.ERROR(e.message ?: "Lesefehler")
                    break
                }
            }
        }.start()
    }

    fun disconnect() {
        _connectionState.value = ConnectionState.DISCONNECTED
        _receivedData.value = ""
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/services/DataService.kt
# TYP: .kt
================================================================================
package com.emfad.app.services

import android.content.Context
import android.util.Log
import com.emfad.app.models.EMFADMeasurement
import com.emfad.app.models.MeasurementSession
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import java.io.File
import java.text.SimpleDateFormat
import java.util.*

class DataService(private val context: Context) {
    private val TAG = "DataService"
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd_HH-mm-ss", Locale.getDefault())
    
    private val _exportProgress = MutableStateFlow<Int>(0)
    val exportProgress: StateFlow<Int> = _exportProgress

    fun exportSessionToFile(session: MeasurementSession): File? {
        return try {
            val fileName = "EMFAD_${dateFormat.format(session.startTime)}.csv"
            val file = File(context.getExternalFilesDir(null), fileName)
            
            file.writeText(session.toCSV())
            file
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim Exportieren der Sitzung: ${e.message}")
            null
        }
    }

    fun exportMeasurementsToFile(measurements: List<EMFADMeasurement>): File? {
        return try {
            val fileName = "EMFAD_Measurements_${dateFormat.format(Date())}.csv"
            val file = File(context.getExternalFilesDir(null), fileName)
            
            val header = "Zeitstempel,E-Feld (V/m),M-Feld (¬µT),Frequenz (Hz),Batterie (%)"
            val rows = measurements.map { measurement ->
                "${measurement.timestamp},${measurement.electricField},${measurement.magneticField},${measurement.frequency},${measurement.batteryLevel}"
            }
            
            file.writeText((listOf(header) + rows).joinToString("\n"))
            file
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim Exportieren der Messungen: ${e.message}")
            null
        }
    }

    fun generateReport(session: MeasurementSession): String {
        val statistics = session.let {
            """
            Messbericht
            -----------
            Startzeit: ${dateFormat.format(it.startTime)}
            Endzeit: ${it.endTime?.let { end -> dateFormat.format(end) } ?: "Laufend"}
            Dauer: ${it.duration / 1000} Sekunden
            Ort: ${it.location}
            Notizen: ${it.notes}
            
            Statistiken:
            - Durchschnittliches E-Feld: ${it.averageElectricField} V/m
            - Durchschnittliches M-Feld: ${it.averageMagneticField} ¬µT
            - Spitzenwert E-Feld: ${it.peakElectricField} V/m
            - Spitzenwert M-Feld: ${it.peakMagneticField} ¬µT
            
            Anzahl Messungen: ${it.measurements.size}
            """.trimIndent()
        }
        
        return statistics
    }

    fun cleanupOldFiles(maxAgeDays: Int = 30) {
        try {
            val directory = context.getExternalFilesDir(null)
            val currentTime = System.currentTimeMillis()
            val maxAgeMillis = maxAgeDays * 24 * 60 * 60 * 1000L
            
            directory?.listFiles()?.forEach { file ->
                if (currentTime - file.lastModified() > maxAgeMillis) {
                    file.delete()
                }
            }
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim Aufr√§umen alter Dateien: ${e.message}")
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/services/MeasurementService.kt
# TYP: .kt
================================================================================
package com.emfad.app.services

import android.content.Context
import android.util.Log
import com.emfad.app.data.MeasurementDatabase
import com.emfad.app.models.EMFADMeasurement
import com.emfad.app.models.MeasurementSession
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import java.util.*

class MeasurementService(private val context: Context) {
    private val TAG = "MeasurementService"
    private val database = MeasurementDatabase.getDatabase(context)
    
    private val _currentSession = MutableStateFlow<MeasurementSession?>(null)
    val currentSession: StateFlow<MeasurementSession?> = _currentSession
    
    private val _measurements = MutableStateFlow<List<EMFADMeasurement>>(emptyList())
    val measurements: StateFlow<List<EMFADMeasurement>> = _measurements

    suspend fun startNewSession(
        deviceId: String,
        location: String = "",
        notes: String = "",
        sessionType: MeasurementSession.SessionType = MeasurementSession.SessionType.STANDARD
    ) {
        val session = MeasurementSession(
            deviceId = deviceId,
            location = location,
            notes = notes,
            sessionType = sessionType
        )
        _currentSession.value = session
        _measurements.value = emptyList()
    }

    suspend fun addMeasurement(rawData: String) {
        val measurement = EMFADMeasurement.fromRawData(rawData)
        measurement?.let {
            _currentSession.value?.addMeasurement(it)
            _measurements.value = _measurements.value + it
            saveMeasurement(it)
        }
    }

    private suspend fun saveMeasurement(measurement: EMFADMeasurement) {
        try {
            database.measurementDao().insertMeasurement(measurement)
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim Speichern der Messung: ${e.message}")
        }
    }

    suspend fun endCurrentSession() {
        _currentSession.value?.endSession()
        _currentSession.value = null
    }

    suspend fun getMeasurementsInRange(startTime: Date, endTime: Date): List<EMFADMeasurement> {
        return try {
            database.measurementDao().getMeasurementsInRange(startTime, endTime)
        } catch (e: Exception) {
            Log.e(TAG, "Fehler beim Abrufen der Messungen: ${e.message}")
            emptyList()
        }
    }

    suspend fun exportSessionToCSV(session: MeasurementSession): String {
        return session.toCSV()
    }

    fun getSessionStatistics(session: MeasurementSession): Map<String, Double> {
        return mapOf(
            "Durchschnittliches E-Feld" to session.averageElectricField,
            "Durchschnittliches M-Feld" to session.averageMagneticField,
            "Spitzenwert E-Feld" to session.peakElectricField,
            "Spitzenwert M-Feld" to session.peakMagneticField
        )
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/ui/MainScreen.kt
# TYP: .kt
================================================================================
package com.emfad.app.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.emfad.app.models.*
import com.emfad.app.viewmodels.MainViewModel
import com.emfad.app.viewmodels.MainUiState
import com.emfad.app.viewmodels.MaterialAnalysisResult

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun MainScreen(
    viewModel: MainViewModel = viewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("EMFAD Scanner") },
                actions = {
                    IconButton(onClick = { /* TODO: Einstellungen √∂ffnen */ }) {
                        Icon(Icons.Default.Settings, "Einstellungen")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Messmodus-Auswahl
            MeasurementModeSelector(
                currentMode = uiState.currentMode,
                onModeSelected = viewModel::setMeasurementMode
            )
            
            // Messung und Kalibrierung
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = viewModel::startMeasurement,
                    enabled = !uiState.isMeasuring && !uiState.isCalibrating,
                    modifier = Modifier.weight(1f)
                ) {
                    if (uiState.isMeasuring) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(24.dp),
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    } else {
                        Text("Messen")
                    }
                }
                
                Button(
                    onClick = viewModel::startCalibration,
                    enabled = !uiState.isMeasuring && !uiState.isCalibrating,
                    modifier = Modifier.weight(1f)
                ) {
                    if (uiState.isCalibrating) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(24.dp),
                            color = MaterialTheme.colorScheme.onPrimary
                        )
                    } else {
                        Text("Kalibrieren")
                    }
                }
            }
            
            // Letzte Messung
            uiState.lastMeasurement?.let { measurement ->
                MeasurementResultCard(measurement)
            }
            
            // Letzte Kalibrierung
            uiState.lastCalibration?.let { calibration ->
                CalibrationResultCard(calibration)
            }
            
            // Materialanalyse
            uiState.materialAnalysis?.let { analysis ->
                MaterialAnalysisCard(analysis)
            }
            
            // Fehlermeldung
            uiState.error?.let { error ->
                ErrorCard(error) {
                    viewModel.clearError()
                }
            }
        }
    }
}

@Composable
fun MeasurementModeSelector(
    currentMode: MeasurementMode,
    onModeSelected: (MeasurementMode) -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                "Messmodus",
                style = MaterialTheme.typography.titleMedium
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                MeasurementMode.values().forEach { mode ->
                    FilterChip(
                        selected = mode == currentMode,
                        onClick = { onModeSelected(mode) },
                        label = {
                            Text(
                                when (mode) {
                                    MeasurementMode.BA_VERTICAL -> "B-A Vertikal"
                                    MeasurementMode.AB_HORIZONTAL -> "A-B Horizontal"
                                    MeasurementMode.ANTENNA_A -> "Antenne A"
                                    MeasurementMode.DEPTH_PRO -> "Tiefenprofil"
                                }
                            )
                        },
                        modifier = Modifier.weight(1f)
                    )
                }
            }
        }
    }
}

@Composable
fun MeasurementResultCard(measurement: MeasurementResult) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                "Letzte Messung",
                style = MaterialTheme.typography.titleMedium
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Frequenz:")
                Text("${measurement.frequency} Hz")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Impedanz:")
                Text("${measurement.impedance.real} + ${measurement.impedance.imaginary}i Œ©")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Tiefe:")
                Text("${measurement.depth} m")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Zuverl√§ssigkeit:")
                Text("${(measurement.confidence * 100).toInt()}%")
            }
        }
    }
}

@Composable
fun CalibrationResultCard(calibration: CalibrationResult) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                "Kalibrierungsergebnis",
                style = MaterialTheme.typography.titleMedium
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Status:")
                Text(
                    if (calibration.success) "Erfolgreich" else "Fehlgeschlagen",
                    color = if (calibration.success)
                        MaterialTheme.colorScheme.primary
                    else
                        MaterialTheme.colorScheme.error
                )
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Kalibrierungsfaktor:")
                Text(calibration.calibrationFactor.toString())
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Zuverl√§ssigkeit:")
                Text("${(calibration.confidence * 100).toInt()}%")
            }
        }
    }
}

@Composable
fun MaterialAnalysisCard(analysis: MaterialAnalysisResult) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                "Materialanalyse",
                style = MaterialTheme.typography.titleMedium
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Material:")
                Text(analysis.materialName)
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Typ:")
                Text(
                    when (analysis.materialType) {
                        MaterialType.NATURAL_VEIN -> "Nat√ºrliche Ader"
                        MaterialType.ARTIFICIAL_STRUCTURE -> "K√ºnstliche Struktur"
                        MaterialType.CRYSTAL -> "Kristall"
                        MaterialType.UNKNOWN -> "Unbekannt"
                    }
                )
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Tiefe:")
                Text("${analysis.depth} m")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Gr√∂√üe:")
                Text("${analysis.size} m")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Zuverl√§ssigkeit:")
                Text("${(analysis.confidence * 100).toInt()}%")
            }
            
            // Materialeigenschaften
            Text(
                "Materialeigenschaften",
                style = MaterialTheme.typography.titleSmall,
                modifier = Modifier.padding(top = 8.dp)
            )
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Leitf√§higkeit:")
                Text("${analysis.properties.conductivity} S/m")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Permittivit√§t:")
                Text("${analysis.properties.permittivity.real} + ${analysis.properties.permittivity.imaginary}i")
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Permeabilit√§t:")
                Text(analysis.properties.permeability.toString())
            }
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text("Dichte:")
                Text("${analysis.properties.density} g/cm¬≥")
            }
        }
    }
}

@Composable
fun ErrorCard(
    error: String,
    onDismiss: () -> Unit
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.errorContainer
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Text(
                error,
                color = MaterialTheme.colorScheme.onErrorContainer,
                modifier = Modifier.weight(1f)
            )
            
            IconButton(onClick = onDismiss) {
                Icon(
                    Icons.Default.Close,
                    "Schlie√üen",
                    tint = MaterialTheme.colorScheme.onErrorContainer
                )
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/ui/SettingsScreen.kt
# TYP: .kt
================================================================================
package com.emfad.app.ui

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.emfad.app.viewmodels.SettingsViewModel
import com.emfad.app.viewmodels.SettingsUiState

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun SettingsScreen(
    onNavigateBack: () -> Unit,
    viewModel: SettingsViewModel = viewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    
    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("Einstellungen") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, "Zur√ºck")
                    }
                }
            )
        }
    ) { padding ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(padding)
                .padding(16.dp)
                .verticalScroll(rememberScrollState()),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Messparameter
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        "Messparameter",
                        style = MaterialTheme.typography.titleMedium
                    )
                    
                    // Frequenz
                    OutlinedTextField(
                        value = uiState.frequency.toString(),
                        onValueChange = { viewModel.setFrequency(it.toDoubleOrNull() ?: 1000.0) },
                        label = { Text("Frequenz (Hz)") },
                        modifier = Modifier.fillMaxWidth()
                    )
                    
                    // Antennenabstand
                    OutlinedTextField(
                        value = uiState.antennaDistance.toString(),
                        onValueChange = { viewModel.setAntennaDistance(it.toDoubleOrNull() ?: 1.0) },
                        label = { Text("Antennenabstand (m)") },
                        modifier = Modifier.fillMaxWidth()
                    )
                    
                    // Messgenauigkeit
                    Column {
                        Text(
                            "Messgenauigkeit",
                            style = MaterialTheme.typography.bodyMedium
                        )
                        
                        Slider(
                            value = uiState.measurementAccuracy,
                            onValueChange = viewModel::setMeasurementAccuracy,
                            valueRange = 0.1f..1.0f,
                            steps = 9,
                            modifier = Modifier.fillMaxWidth()
                        )
                        
                        Text(
                            "${(uiState.measurementAccuracy * 100).toInt()}%",
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }
            
            // Kalibrierung
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        "Kalibrierung",
                        style = MaterialTheme.typography.titleMedium
                    )
                    
                    // Automatische Kalibrierung
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Automatische Kalibrierung")
                        Switch(
                            checked = uiState.autoCalibration,
                            onCheckedChange = viewModel::setAutoCalibration
                        )
                    }
                    
                    // Kalibrierungsgenauigkeit
                    Column {
                        Text(
                            "Kalibrierungsgenauigkeit",
                            style = MaterialTheme.typography.bodyMedium
                        )
                        
                        Slider(
                            value = uiState.calibrationAccuracy,
                            onValueChange = viewModel::setCalibrationAccuracy,
                            valueRange = 0.1f..1.0f,
                            steps = 9,
                            modifier = Modifier.fillMaxWidth()
                        )
                        
                        Text(
                            "${(uiState.calibrationAccuracy * 100).toInt()}%",
                            style = MaterialTheme.typography.bodySmall
                        )
                    }
                }
            }
            
            // Materialerkennung
            Card(
                modifier = Modifier.fillMaxWidth()
            ) {
                Column(
                    modifier = Modifier.padding(16.dp),
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        "Materialerkennung",
                        style = MaterialTheme.typography.titleMedium
                    )
                    
                    // Metallerkennung
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Metallerkennung")
                        Switch(
                            checked = uiState.metalDetection,
                            onCheckedChange = viewModel::setMetalDetection
                        )
                    }
                    
                    // Kristallerfassung
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Kristallerfassung")
                        Switch(
                            checked = uiState.crystalDetection,
                            onCheckedChange = viewModel::setCrystalDetection
                        )
                    }
                    
                    // Clusteranalyse
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Clusteranalyse")
                        Switch(
                            checked = uiState.clusterAnalysis,
                            onCheckedChange = viewModel::setClusterAnalysis
                        )
                    }
                    
                    // Einschlussanalyse
                    Row(
                        modifier = Modifier.fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        Text("Einschlussanalyse")
                        Switch(
                            checked = uiState.inclusionAnalysis,
                            onCheckedChange = viewModel::setInclusionAnalysis
                        )
                    }
                }
            }
            
            // Speichern-Button
            Button(
                onClick = {
                    viewModel.saveSettings()
                    onNavigateBack()
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("Einstellungen speichern")
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/ui/theme/Theme.kt
# TYP: .kt
================================================================================
package com.emfad.app.ui.theme

import android.app.Activity
import android.os.Build
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.dynamicDarkColorScheme
import androidx.compose.material3.dynamicLightColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.runtime.SideEffect
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.core.view.WindowCompat

private val DarkColorScheme = darkColorScheme(
    primary = Color(0xFF90CAF9),
    onPrimary = Color(0xFF003258),
    primaryContainer = Color(0xFF00497D),
    onPrimaryContainer = Color(0xFFD1E4FF),
    secondary = Color(0xFFB4C6EA),
    onSecondary = Color(0xFF1F2B4D),
    secondaryContainer = Color(0xFF374766),
    onSecondaryContainer = Color(0xFFD7E3FF),
    tertiary = Color(0xFFE0B2CE),
    onTertiary = Color(0xFF492532),
    tertiaryContainer = Color(0xFF633B48),
    onTertiaryContainer = Color(0xFFFFD8E8),
    error = Color(0xFFFFB4AB),
    errorContainer = Color(0xFF93000A),
    onError = Color(0xFF690005),
    onErrorContainer = Color(0xFFFFDAD6),
    background = Color(0xFF1A1C1E),
    onBackground = Color(0xFFE2E2E6),
    surface = Color(0xFF1A1C1E),
    onSurface = Color(0xFFE2E2E6),
    surfaceVariant = Color(0xFF42474E),
    onSurfaceVariant = Color(0xFFC2C7CF),
    outline = Color(0xFF8C9199),
    inverseOnSurface = Color(0xFF1A1C1E),
    inverseSurface = Color(0xFFE2E2E6),
    inversePrimary = Color(0xFF0061A4),
    surfaceTint = Color(0xFF90CAF9),
    outlineVariant = Color(0xFF42474E),
    scrim = Color(0xFF000000)
)

private val LightColorScheme = lightColorScheme(
    primary = Color(0xFF0061A4),
    onPrimary = Color(0xFFFFFFFF),
    primaryContainer = Color(0xFFD1E4FF),
    onPrimaryContainer = Color(0xFF001D36),
    secondary = Color(0xFF535F70),
    onSecondary = Color(0xFFFFFFFF),
    secondaryContainer = Color(0xFFD7E3FF),
    onSecondaryContainer = Color(0xFF101C2B),
    tertiary = Color(0xFF6B5778),
    onTertiary = Color(0xFFFFFFFF),
    tertiaryContainer = Color(0xFFF2DAFF),
    onTertiaryContainer = Color(0xFF251431),
    error = Color(0xFFBA1A1A),
    errorContainer = Color(0xFFFFDAD6),
    onError = Color(0xFFFFFFFF),
    onErrorContainer = Color(0xFF410002),
    background = Color(0xFFFDFCFF),
    onBackground = Color(0xFF1A1C1E),
    surface = Color(0xFFFDFCFF),
    onSurface = Color(0xFF1A1C1E),
    surfaceVariant = Color(0xFFDFE2EB),
    onSurfaceVariant = Color(0xFF42474E),
    outline = Color(0xFF73777F),
    inverseOnSurface = Color(0xFFF1F0F4),
    inverseSurface = Color(0xFF2F3033),
    inversePrimary = Color(0xFF90CAF9),
    surfaceTint = Color(0xFF0061A4),
    outlineVariant = Color(0xFFC2C7CF),
    scrim = Color(0xFF000000)
)

@Composable
fun EMFADAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    dynamicColor: Boolean = true,
    content: @Composable () -> Unit
) {
    val colorScheme = when {
        dynamicColor && Build.VERSION.SDK_INT >= Build.VERSION_CODES.S -> {
            val context = LocalContext.current
            if (darkTheme) dynamicDarkColorScheme(context) else dynamicLightColorScheme(context)
        }
        darkTheme -> DarkColorScheme
        else -> LightColorScheme
    }
    val view = LocalView.current
    if (!view.isInEditMode) {
        SideEffect {
            val window = (view.context as Activity).window
            window.statusBarColor = colorScheme.primary.toArgb()
            WindowCompat.getInsetsController(window, view).isAppearanceLightStatusBars = !darkTheme
        }
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = Typography,
        content = content
    )
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/ui/theme/Type.kt
# TYP: .kt
================================================================================
package com.emfad.app.ui.theme

import androidx.compose.material3.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    displayLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 57.sp,
        lineHeight = 64.sp,
        letterSpacing = (-0.25).sp
    ),
    displayMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 45.sp,
        lineHeight = 52.sp,
        letterSpacing = 0.sp
    ),
    displaySmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 36.sp,
        lineHeight = 44.sp,
        letterSpacing = 0.sp
    ),
    headlineLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 32.sp,
        lineHeight = 40.sp,
        letterSpacing = 0.sp
    ),
    headlineMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 28.sp,
        lineHeight = 36.sp,
        letterSpacing = 0.sp
    ),
    headlineSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 24.sp,
        lineHeight = 32.sp,
        letterSpacing = 0.sp
    ),
    titleLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 22.sp,
        lineHeight = 28.sp,
        letterSpacing = 0.sp
    ),
    titleMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.15.sp
    ),
    titleSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp
    ),
    bodyLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp,
        lineHeight = 24.sp,
        letterSpacing = 0.5.sp
    ),
    bodyMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.25.sp
    ),
    bodySmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.4.sp
    ),
    labelLarge = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 14.sp,
        lineHeight = 20.sp,
        letterSpacing = 0.1.sp
    ),
    labelMedium = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 12.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    ),
    labelSmall = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Medium,
        fontSize = 11.sp,
        lineHeight = 16.sp,
        letterSpacing = 0.5.sp
    )
) 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/viewmodels/BluetoothViewModel.kt
# TYP: .kt
================================================================================
package com.emfad.app.viewmodels

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.emfad.app.models.EMFADDevice
import com.emfad.app.services.BluetoothService
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

class BluetoothViewModel(application: Application) : AndroidViewModel(application) {
    private val bluetoothService = BluetoothService(application)
    
    private val _uiState = MutableStateFlow<BluetoothUiState>(BluetoothUiState.Initial)
    val uiState: StateFlow<BluetoothUiState> = _uiState.asStateFlow()
    
    private val _isScanning = MutableStateFlow(false)
    val isScanning: StateFlow<Boolean> = _isScanning.asStateFlow()

    init {
        viewModelScope.launch {
            bluetoothService.connectionState.collect { state ->
                _uiState.value = when (state) {
                    is BluetoothService.ConnectionState.CONNECTED -> BluetoothUiState.Connected
                    is BluetoothService.ConnectionState.CONNECTING -> BluetoothUiState.Connecting
                    is BluetoothService.ConnectionState.DISCONNECTED -> BluetoothUiState.Disconnected
                    is BluetoothService.ConnectionState.ERROR -> BluetoothUiState.Error(state.message)
                }
            }
        }
    }

    fun startDeviceScan() {
        _isScanning.value = true
        bluetoothService.startDiscovery()
    }

    fun stopDeviceScan() {
        _isScanning.value = false
        bluetoothService.stopDiscovery()
    }

    fun connectToDevice(device: EMFADDevice) {
        bluetoothService.connectToDevice(device)
    }

    fun disconnect() {
        bluetoothService.disconnect()
    }

    fun onDeviceFound(device: EMFADDevice) {
        bluetoothService.onDeviceFound(device.bluetoothDevice)
    }

    sealed class BluetoothUiState {
        object Initial : BluetoothUiState()
        object Connected : BluetoothUiState()
        object Connecting : BluetoothUiState()
        object Disconnected : BluetoothUiState()
        data class Error(val message: String) : BluetoothUiState()
    }

    override fun onCleared() {
        super.onCleared()
        bluetoothService.disconnect()
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/viewmodels/MainViewModel.kt
# TYP: .kt
================================================================================
package com.emfad.app.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.emfad.app.models.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class MainUiState(
    val currentMode: MeasurementMode = MeasurementMode.BA_VERTICAL,
    val isMeasuring: Boolean = false,
    val isCalibrating: Boolean = false,
    val lastMeasurement: MeasurementResult? = null,
    val lastCalibration: CalibrationResult? = null,
    val materialAnalysis: MaterialAnalysisResult? = null,
    val error: String? = null
)

data class MaterialAnalysisResult(
    val materialType: MaterialType,
    val materialName: String,
    val depth: Double,
    val size: Double,
    val confidence: Double,
    val properties: MaterialProperties
)

class MainViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(MainUiState())
    val uiState: StateFlow<MainUiState> = _uiState.asStateFlow()
    
    private val measurementController = MeasurementController()
    private val automaticCalibration = AutomaticCalibration()
    private val materialDatabase = MaterialDatabase()
    private val metalAnalyzer = MetalAnalyzer()
    private val crystalDetector = CrystalDetector()
    private val clusterAnalyzer = ClusterAnalyzer()
    private val inclusionDetector = InclusionDetector()
    
    fun setMeasurementMode(mode: MeasurementMode) {
        viewModelScope.launch {
            _uiState.value = _uiState.value.copy(
                currentMode = mode,
                error = null
            )
            measurementController.setMode(mode)
            automaticCalibration.setMode(mode)
        }
    }
    
    fun startMeasurement() {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(
                    isMeasuring = true,
                    error = null
                )
                
                val result = measurementController.measure()
                _uiState.value = _uiState.value.copy(
                    lastMeasurement = result,
                    isMeasuring = false
                )
                
                // F√ºhre Materialanalyse durch
                analyzeMaterial(result)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isMeasuring = false,
                    error = "Messfehler: ${e.message}"
                )
            }
        }
    }
    
    fun startCalibration() {
        viewModelScope.launch {
            try {
                _uiState.value = _uiState.value.copy(
                    isCalibrating = true,
                    error = null
                )
                
                val result = automaticCalibration.calibrate()
                _uiState.value = _uiState.value.copy(
                    lastCalibration = result,
                    isCalibrating = false
                )
                
                if (result.success) {
                    measurementController.updateConfig(
                        MeasurementConfig(
                            mode = result.mode,
                            frequency = 1000.0, // Standardfrequenz
                            antennaDistance = 1.0, // Standardabstand
                            calibrationFactor = result.calibrationFactor,
                            isCalibrated = true
                        )
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    isCalibrating = false,
                    error = "Kalibrierungsfehler: ${e.message}"
                )
            }
        }
    }
    
    fun addCalibrationPoint(point: CalibrationPoint) {
        viewModelScope.launch {
            try {
                automaticCalibration.addCalibrationPoint(point)
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Fehler beim Hinzuf√ºgen des Kalibrierungspunkts: ${e.message}"
                )
            }
        }
    }
    
    private fun analyzeMaterial(measurement: MeasurementResult) {
        viewModelScope.launch {
            try {
                // 1. Metallanalyse
                val metalResult = metalAnalyzer.analyzeMetal(
                    impedanceCurve = listOf(
                        measurement.frequency to measurement.impedance
                    ),
                    frequency = measurement.frequency
                )
                
                // 2. Kristallanalyse
                val crystalResult = crystalDetector.detectCrystal(
                    measuredZ = measurement.impedance,
                    backgroundZ = Complex(377.0, 0.0),
                    frequency = measurement.frequency,
                    noiseStdDev = 0.1
                )
                
                // 3. Clusteranalyse
                val clusterResult = clusterAnalyzer.analyzeClusters(
                    listOf(
                        MeasurementPoint(
                            impedance = measurement.impedance,
                            conductivity = metalResult.conductivity,
                            permittivity = crystalResult.permittivity,
                            permeability = 1.0,
                            depth = measurement.depth,
                            position = Point3D(0.0, 0.0, measurement.depth)
                        )
                    )
                )
                
                // 4. Einschlussanalyse
                val inclusionResult = inclusionDetector.detectInclusion(
                    measuredZ = measurement.impedance,
                    frequency = measurement.frequency,
                    depth = measurement.depth,
                    surroundingMaterial = MaterialProperties(
                        name = "Erde",
                        conductivity = 1e-3,
                        permittivity = Complex(4.0, 0.0),
                        permeability = 1.0,
                        density = 1.5,
                        type = MaterialType.UNKNOWN,
                        color = "Braun",
                        typicalDepth = 0.0,
                        typicalSize = 0.0
                    )
                )
                
                // Bestimme das wahrscheinlichste Material
                val material = materialDatabase.findMatchingMaterial(
                    conductivity = metalResult.conductivity,
                    permittivity = crystalResult.permittivity,
                    permeability = 1.0,
                    density = 2.0 // Standarddichte
                )
                
                if (material != null) {
                    _uiState.value = _uiState.value.copy(
                        materialAnalysis = MaterialAnalysisResult(
                            materialType = material.type,
                            materialName = material.name,
                            depth = measurement.depth,
                            size = material.typicalSize,
                            confidence = measurement.confidence,
                            properties = material
                        )
                    )
                }
            } catch (e: Exception) {
                _uiState.value = _uiState.value.copy(
                    error = "Analysefehler: ${e.message}"
                )
            }
        }
    }
    
    fun clearError() {
        _uiState.value = _uiState.value.copy(error = null)
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/viewmodels/MeasurementViewModel.kt
# TYP: .kt
================================================================================
package com.emfad.app.viewmodels

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.viewModelScope
import com.emfad.app.models.EMFADMeasurement
import com.emfad.app.models.MeasurementSession
import com.emfad.app.services.DataService
import com.emfad.app.services.MeasurementService
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch
import java.util.*

class MeasurementViewModel(application: Application) : AndroidViewModel(application) {
    private val measurementService = MeasurementService(application)
    private val dataService = DataService(application)
    
    private val _uiState = MutableStateFlow<MeasurementUiState>(MeasurementUiState.Initial)
    val uiState: StateFlow<MeasurementUiState> = _uiState.asStateFlow()
    
    private val _currentSession = MutableStateFlow<MeasurementSession?>(null)
    val currentSession: StateFlow<MeasurementSession?> = _currentSession.asStateFlow()
    
    private val _measurements = MutableStateFlow<List<EMFADMeasurement>>(emptyList())
    val measurements: StateFlow<List<EMFADMeasurement>> = _measurements.asStateFlow()
    
    private val _statistics = MutableStateFlow<Map<String, Double>>(emptyMap())
    val statistics: StateFlow<Map<String, Double>> = _statistics.asStateFlow()

    private val _materialAnalysis = MutableStateFlow<MaterialAnalysis?>(null)
    val materialAnalysis: StateFlow<MaterialAnalysis?> = _materialAnalysis.asStateFlow()

    init {
        viewModelScope.launch {
            measurementService.currentSession.collect { session ->
                _currentSession.value = session
                session?.let { updateStatistics(it) }
            }
        }
        
        viewModelScope.launch {
            measurementService.measurements.collect { measurements ->
                _measurements.value = measurements
                measurements.lastOrNull()?.let { measurement ->
                    _materialAnalysis.value = MaterialAnalyzer.analyzeMeasurement(measurement)
                }
            }
        }
    }

    fun startNewSession(
        deviceId: String,
        location: String = "",
        notes: String = "",
        sessionType: MeasurementSession.SessionType = MeasurementSession.SessionType.STANDARD
    ) {
        viewModelScope.launch {
            measurementService.startNewSession(deviceId, location, notes, sessionType)
            _uiState.value = MeasurementUiState.Measuring
        }
    }

    fun addMeasurement(rawData: String) {
        viewModelScope.launch {
            measurementService.addMeasurement(rawData)
        }
    }

    fun endCurrentSession() {
        viewModelScope.launch {
            measurementService.endCurrentSession()
            _uiState.value = MeasurementUiState.SessionEnded
        }
    }

    fun exportCurrentSession() {
        viewModelScope.launch {
            _currentSession.value?.let { session ->
                val file = dataService.exportSessionToFile(session)
                _uiState.value = if (file != null) {
                    MeasurementUiState.ExportSuccess(file.absolutePath)
                } else {
                    MeasurementUiState.ExportError
                }
            }
        }
    }

    private fun updateStatistics(session: MeasurementSession) {
        _statistics.value = measurementService.getSessionStatistics(session)
    }

    fun generateReport(): String {
        return _currentSession.value?.let { session ->
            dataService.generateReport(session)
        } ?: "Keine aktive Messsitzung"
    }

    sealed class MeasurementUiState {
        object Initial : MeasurementUiState()
        object Measuring : MeasurementUiState()
        object SessionEnded : MeasurementUiState()
        data class ExportSuccess(val filePath: String) : MeasurementUiState()
        object ExportError : MeasurementUiState()
    }

    override fun onCleared() {
        super.onCleared()
        viewModelScope.launch {
            measurementService.endCurrentSession()
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/viewmodels/SettingsViewModel.kt
# TYP: .kt
================================================================================
package com.emfad.app.viewmodels

import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.launch

data class SettingsUiState(
    val frequency: Double = 1000.0,
    val antennaDistance: Double = 1.0,
    val measurementAccuracy: Float = 0.8f,
    val autoCalibration: Boolean = true,
    val calibrationAccuracy: Float = 0.8f,
    val metalDetection: Boolean = true,
    val crystalDetection: Boolean = true,
    val clusterAnalysis: Boolean = true,
    val inclusionAnalysis: Boolean = true
)

class SettingsViewModel : ViewModel() {
    private val _uiState = MutableStateFlow(SettingsUiState())
    val uiState: StateFlow<SettingsUiState> = _uiState.asStateFlow()
    
    fun setFrequency(frequency: Double) {
        _uiState.value = _uiState.value.copy(frequency = frequency)
    }
    
    fun setAntennaDistance(distance: Double) {
        _uiState.value = _uiState.value.copy(antennaDistance = distance)
    }
    
    fun setMeasurementAccuracy(accuracy: Float) {
        _uiState.value = _uiState.value.copy(measurementAccuracy = accuracy)
    }
    
    fun setAutoCalibration(enabled: Boolean) {
        _uiState.value = _uiState.value.copy(autoCalibration = enabled)
    }
    
    fun setCalibrationAccuracy(accuracy: Float) {
        _uiState.value = _uiState.value.copy(calibrationAccuracy = accuracy)
    }
    
    fun setMetalDetection(enabled: Boolean) {
        _uiState.value = _uiState.value.copy(metalDetection = enabled)
    }
    
    fun setCrystalDetection(enabled: Boolean) {
        _uiState.value = _uiState.value.copy(crystalDetection = enabled)
    }
    
    fun setClusterAnalysis(enabled: Boolean) {
        _uiState.value = _uiState.value.copy(clusterAnalysis = enabled)
    }
    
    fun setInclusionAnalysis(enabled: Boolean) {
        _uiState.value = _uiState.value.copy(inclusionAnalysis = enabled)
    }
    
    fun saveSettings() {
        viewModelScope.launch {
            // TODO: Einstellungen in SharedPreferences speichern
        }
    }
    
    fun loadSettings() {
        viewModelScope.launch {
            // TODO: Einstellungen aus SharedPreferences laden
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/BluetoothPage.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.emfad.app.models.EMFADDevice
import com.emfad.app.viewmodels.BluetoothViewModel

@Composable
fun BluetoothPage(
    viewModel: BluetoothViewModel = viewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val isScanning by viewModel.isScanning.collectAsState()
    val discoveredDevices by viewModel.discoveredDevices.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Status-Anzeige
        Card(
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 16.dp)
        ) {
            Column(
                modifier = Modifier.padding(16.dp)
            ) {
                Text(
                    text = "Bluetooth-Status: ${
                        when (uiState) {
                            is BluetoothViewModel.BluetoothUiState.Connected -> "Verbunden"
                            is BluetoothViewModel.BluetoothUiState.Connecting -> "Verbinde..."
                            is BluetoothViewModel.BluetoothUiState.Disconnected -> "Getrennt"
                            is BluetoothViewModel.BluetoothUiState.Error -> "Fehler: ${(uiState as BluetoothViewModel.BluetoothUiState.Error).message}"
                            else -> "Initial"
                        }
                    }",
                    style = MaterialTheme.typography.h6
                )
            }
        }

        // Scan-Button
        Button(
            onClick = { 
                if (isScanning) viewModel.stopDeviceScan() else viewModel.startDeviceScan()
            },
            modifier = Modifier
                .fillMaxWidth()
                .padding(bottom = 16.dp)
        ) {
            Text(if (isScanning) "Scan stoppen" else "Nach Ger√§ten suchen")
        }

        // Ger√§teliste
        LazyColumn(
            modifier = Modifier.fillMaxWidth()
        ) {
            items(discoveredDevices) { device ->
                DeviceItem(
                    device = device,
                    onConnectClick = { viewModel.connectToDevice(device) }
                )
            }
        }
    }
}

@Composable
private fun DeviceItem(
    device: EMFADDevice,
    onConnectClick: () -> Unit
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column {
                Text(
                    text = device.name,
                    style = MaterialTheme.typography.h6
                )
                Text(
                    text = device.address,
                    style = MaterialTheme.typography.body2
                )
            }
            Button(
                onClick = onConnectClick,
                enabled = !device.isConnected
            ) {
                Text(if (device.isConnected) "Verbunden" else "Verbinden")
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MainView.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.emfad.app.models.*

@Composable
fun MainView(
    viewModel: MainViewModel,
    modifier: Modifier = Modifier
) {
    var selectedTab by remember { mutableStateOf(0) }
    var isCalibrating by remember { mutableStateOf(false) }
    
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Tabs f√ºr verschiedene Ansichten
        TabRow(selectedTabIndex = selectedTab) {
            Tab(
                selected = selectedTab == 0,
                onClick = { selectedTab = 0 },
                text = { Text("Messung") }
            )
            Tab(
                selected = selectedTab == 1,
                onClick = { selectedTab = 1 },
                text = { Text("Kalibrierung") }
            )
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Messmodus-Auswahl
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            MeasurementMode.values().forEach { mode ->
                FilterChip(
                    selected = viewModel.currentMode.value == mode,
                    onClick = { viewModel.setMeasurementMode(mode) },
                    label = {
                        Text(
                            when (mode) {
                                MeasurementMode.B_A_VERTICAL -> "B-A Vertikal"
                                MeasurementMode.A_B_HORIZONTAL -> "A-B Horizontal"
                                MeasurementMode.ANTENNA_A -> "Antenne A"
                                MeasurementMode.DEPTH_PRO -> "Tiefe Pro"
                            }
                        )
                    }
                )
            }
        }
        
        Spacer(modifier = Modifier.height(16.dp))
        
        // Inhalt basierend auf ausgew√§hltem Tab
        when (selectedTab) {
            0 -> {
                // Messungsansicht
                Column {
                    // Messwerte
                    MeasurementCard(
                        measurement = viewModel.currentMeasurement,
                        modifier = Modifier.fillMaxWidth()
                    )
                    
                    Spacer(modifier = Modifier.height(16.dp))
                    
                    // Materialanalyse
                    viewModel.currentAnalysis?.let { analysis ->
                        MaterialPhysicsAnalysisCard(
                            analysis = analysis,
                            modifier = Modifier.fillMaxWidth()
                        )
                        
                        Spacer(modifier = Modifier.height(16.dp))
                        
                        // 3D-Visualisierung
                        Material3DVisualization(
                            analysis = analysis,
                            modifier = Modifier.fillMaxWidth()
                        )
                    }
                }
            }
            1 -> {
                // Kalibrierungsansicht
                Column {
                    // Automatische Kalibrierung
                    Card(
                        modifier = Modifier
                            .fillMaxWidth()
                            .padding(bottom = 16.dp)
                    ) {
                        Column(
                            modifier = Modifier.padding(16.dp)
                        ) {
                            Text(
                                text = "Automatische Kalibrierung",
                                style = MaterialTheme.typography.h6
                            )
                            
                            Spacer(modifier = Modifier.height(8.dp))
                            
                            Text(
                                text = viewModel.getCalibrationStatus(),
                                style = MaterialTheme.typography.body1
                            )
                            
                            Spacer(modifier = Modifier.height(16.dp))
                            
                            Row(
                                modifier = Modifier.fillMaxWidth(),
                                horizontalArrangement = Arrangement.SpaceEvenly
                            ) {
                                Button(
                                    onClick = {
                                        if (isCalibrating) {
                                            viewModel.finishCalibration()
                                            isCalibrating = false
                                        } else {
                                            viewModel.startCalibration()
                                            isCalibrating = true
                                        }
                                    }
                                ) {
                                    Text(if (isCalibrating) "Kalibrierung beenden" else "Kalibrierung starten")
                                }
                            }
                        }
                    }
                    
                    // Manuelle Kalibrierung
                    MaterialCalibrationView(
                        calibration = viewModel.calibration,
                        onAddCalibrationPoint = { calibrationData ->
                            viewModel.addCalibrationPoint(calibrationData)
                        },
                        onRemoveCalibrationPoint = { calibrationData ->
                            viewModel.removeCalibrationPoint(calibrationData)
                        },
                        modifier = Modifier.fillMaxWidth()
                    )
                }
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/Material3DVisualization.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.Canvas
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.drawscope.*
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.dp
import com.emfad.app.models.MaterialPhysicsAnalysis
import com.emfad.app.models.MaterialType
import com.emfad.app.models.LayerAnalysis
import kotlin.math.*

@Composable
fun Material3DVisualization(
    analysis: MaterialPhysicsAnalysis,
    modifier: Modifier = Modifier
) {
    var rotationX by remember { mutableStateOf(0f) }
    var rotationY by remember { mutableStateOf(0f) }
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(300.dp)
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "3D-Materialvisualisierung",
                style = MaterialTheme.typography.h6
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Canvas(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(200.dp)
                    .pointerInput(Unit) {
                        detectDragGestures { change, dragAmount ->
                            rotationX += dragAmount.y * 0.5f
                            rotationY += dragAmount.x * 0.5f
                        }
                    }
                    .pointerInput(Unit) {
                        detectTransformGestures { centroid, pan, zoom, rotation ->
                            scale = (scale * zoom).coerceIn(0.5f, 3f)
                            offset += pan
                        }
                    }
            ) {
                val width = size.width
                val height = size.height
                val centerX = width / 2 + offset.x
                val centerY = height / 2 + offset.y
                
                // Hintergrund
                drawRect(
                    color = Color.LightGray.copy(alpha = 0.2f),
                    size = size
                )
                
                // Transformiere den Zeichenbereich
                scale(scale) {
                    // Koordinatensystem
                    drawCoordinateSystem(width, height, rotationX, rotationY, centerX, centerY)
                    
                    // Schichtanalyse
                    analysis.layerAnalysis.forEach { layer ->
                        drawLayer(layer, rotationX, rotationY, centerX, centerY)
                    }
                    
                    // Materialvisualisierung
                    when (analysis.materialType) {
                        MaterialType.FERROUS_METAL -> drawFerrousMetal(
                            depth = analysis.depth,
                            size = analysis.size,
                            confidence = analysis.confidence,
                            rotationX = rotationX,
                            rotationY = rotationY,
                            centerX = centerX,
                            centerY = centerY
                        )
                        MaterialType.NON_FERROUS_METAL -> drawNonFerrousMetal(
                            depth = analysis.depth,
                            size = analysis.size,
                            confidence = analysis.confidence,
                            rotationX = rotationX,
                            rotationY = rotationY,
                            centerX = centerX,
                            centerY = centerY
                        )
                        MaterialType.CAVITY -> drawCavity(
                            depth = analysis.depth,
                            size = analysis.size,
                            confidence = analysis.confidence,
                            rotationX = rotationX,
                            rotationY = rotationY,
                            centerX = centerX,
                            centerY = centerY
                        )
                        else -> drawUnknownMaterial(
                            depth = analysis.depth,
                            size = analysis.size,
                            rotationX = rotationX,
                            rotationY = rotationY,
                            centerX = centerX,
                            centerY = centerY
                        )
                    }
                    
                    // Anomalien zeichnen
                    drawAnomalies(analysis, rotationX, rotationY, centerX, centerY)
                }
            }
            
            // Zoom-Steuerung
            Row(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(top = 8.dp),
                horizontalArrangement = Arrangement.Center
            ) {
                Button(
                    onClick = { scale = (scale * 0.8f).coerceIn(0.5f, 3f) },
                    modifier = Modifier.padding(end = 8.dp)
                ) {
                    Text("-")
                }
                Button(
                    onClick = { scale = 1f },
                    modifier = Modifier.padding(horizontal = 8.dp)
                ) {
                    Text("Reset")
                }
                Button(
                    onClick = { scale = (scale * 1.2f).coerceIn(0.5f, 3f) },
                    modifier = Modifier.padding(start = 8.dp)
                ) {
                    Text("+")
                }
            }
        }
    }
}

private fun DrawScope.drawCoordinateSystem(
    width: Float,
    height: Float,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    // Transformiere Koordinaten basierend auf Rotation
    val transform = Matrix().apply {
        rotate(rotationX, centerX, centerY)
        rotate(rotationY, centerX, centerY)
    }
    
    // X-Achse
    drawLine(
        color = Color.Gray,
        start = transform.map(Offset(0f, centerY)),
        end = transform.map(Offset(width, centerY)),
        strokeWidth = 2f
    )
    
    // Y-Achse
    drawLine(
        color = Color.Gray,
        start = transform.map(Offset(centerX, 0f)),
        end = transform.map(Offset(centerX, height)),
        strokeWidth = 2f
    )
    
    // Z-Achse (perspektivisch)
    drawLine(
        color = Color.Gray,
        start = transform.map(Offset(centerX, centerY)),
        end = transform.map(Offset(centerX + width * 0.3f, centerY - height * 0.3f)),
        strokeWidth = 2f
    )
}

private fun DrawScope.drawFerrousMetal(
    depth: Float,
    size: Float,
    confidence: Float,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    val color = Color.Red.copy(alpha = confidence)
    drawMaterialObject(depth, size, color, rotationX, rotationY, centerX, centerY)
}

private fun DrawScope.drawNonFerrousMetal(
    depth: Float,
    size: Float,
    confidence: Float,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    val color = Color.Yellow.copy(alpha = confidence)
    drawMaterialObject(depth, size, color, rotationX, rotationY, centerX, centerY)
}

private fun DrawScope.drawCavity(
    depth: Float,
    size: Float,
    confidence: Float,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    val color = Color.Blue.copy(alpha = confidence)
    drawMaterialObject(depth, size, color, rotationX, rotationY, centerX, centerY, isCavity = true)
}

private fun DrawScope.drawUnknownMaterial(
    depth: Float,
    size: Float,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    val color = Color.Gray.copy(alpha = 0.5f)
    drawMaterialObject(depth, size, color, rotationX, rotationY, centerX, centerY)
}

private fun DrawScope.drawMaterialObject(
    depth: Float,
    size: Float,
    color: Color,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float,
    isCavity: Boolean = false
) {
    val width = size.width
    val height = size.height
    
    // Skalierungsfaktoren
    val depthScale = height / 2000f
    val sizeScale = width / 1000f
    
    // 3D-Koordinaten berechnen
    val x = centerX
    val y = centerY - (depth * depthScale)
    val z = depth * depthScale * 0.5f
    
    // Transformiere Koordinaten
    val transform = Matrix().apply {
        rotate(rotationX, centerX, centerY)
        rotate(rotationY, centerX, centerY)
    }
    
    if (isCavity) {
        // Hohlraum als 3D-Ellipse
        val path = Path().apply {
            addOval(Rect(
                left = x - size * sizeScale / 2,
                top = y - size * sizeScale / 4,
                right = x + size * sizeScale / 2,
                bottom = y + size * sizeScale / 4
            ))
        }
        
        drawPath(
            path = transform.map(path),
            color = color,
            style = Stroke(width = 3f, pathEffect = PathEffect.dashPathEffect(floatArrayOf(10f, 10f)))
        )
    } else {
        // 3D-W√ºrfel mit allen Seiten
        val vertices = listOf(
            Offset(x - size * sizeScale / 2, y),
            Offset(x + size * sizeScale / 2, y),
            Offset(x + size * sizeScale / 2, y - z),
            Offset(x - size * sizeScale / 2, y - z),
            Offset(x - size * sizeScale / 2, y + z),
            Offset(x + size * sizeScale / 2, y + z)
        )
        
        // Vorderseite
        drawPath(
            path = Path().apply {
                moveTo(vertices[0])
                lineTo(vertices[1])
                lineTo(vertices[2])
                lineTo(vertices[3])
                close()
            }.let { transform.map(it) },
            color = color,
            style = Fill
        )
        
        // R√ºckseite
        drawPath(
            path = Path().apply {
                moveTo(vertices[4])
                lineTo(vertices[5])
                lineTo(vertices[2])
                lineTo(vertices[3])
                close()
            }.let { transform.map(it) },
            color = color.copy(alpha = 0.7f),
            style = Fill
        )
        
        // Kanten
        vertices.forEachIndexed { i, vertex ->
            val nextVertex = vertices[(i + 1) % vertices.size]
            drawLine(
                color = color.copy(alpha = 0.5f),
                start = transform.map(vertex),
                end = transform.map(nextVertex),
                strokeWidth = 2f
            )
        }
    }
}

private fun DrawScope.drawLayer(
    layer: LayerAnalysis,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    val width = size.width
    val height = size.height
    
    // Transformiere Koordinaten
    val transform = Matrix().apply {
        rotate(rotationX, centerX, centerY)
        rotate(rotationY, centerX, centerY)
    }
    
    // Schichtebene zeichnen
    val y = centerY - (layer.depth * (height / 2000f))
    val path = Path().apply {
        moveTo(0f, y)
        lineTo(width, y)
        lineTo(width, y - 20f)
        lineTo(0f, y - 20f)
        close()
    }
    
    // Schichtfl√§che
    drawPath(
        path = transform.map(path),
        color = Color.Gray.copy(alpha = 0.2f),
        style = Fill
    )
    
    // Schichtkanten
    drawPath(
        path = transform.map(path),
        color = Color.Gray.copy(alpha = 0.5f),
        style = Stroke(width = 1f)
    )
    
    // Schichtbeschriftung
    drawContext.canvas.nativeCanvas.apply {
        val transformedY = transform.map(Offset(10f, y - 5f)).y
        drawText(
            "${layer.material} (${layer.depth}mm)",
            10f,
            transformedY,
            android.graphics.Paint().apply {
                color = android.graphics.Color.GRAY
                textSize = 24f
            }
        )
    }
}

private fun DrawScope.drawAnomalies(
    analysis: MaterialPhysicsAnalysis,
    rotationX: Float,
    rotationY: Float,
    centerX: Float,
    centerY: Float
) {
    val width = size.width
    val height = size.height
    
    // Transformiere Koordinaten
    val transform = Matrix().apply {
        rotate(rotationX, centerX, centerY)
        rotate(rotationY, centerX, centerY)
    }
    
    // Anomalien basierend auf Magnetgradient und Leitf√§higkeit
    val anomalyIntensity = analysis.magneticGradient * analysis.conductivity / 1e6f
    
    if (anomalyIntensity > 0.1f) {
        val radius = anomalyIntensity * 50f
        val path = Path().apply {
            addCircle(centerX, centerY - analysis.depth * (height / 2000f), radius)
        }
        
        // Anomalie-Halo
        drawPath(
            path = transform.map(path),
            color = Color.Red.copy(alpha = 0.2f),
            style = Fill
        )
        
        // Anomalie-Kontur
        drawPath(
            path = transform.map(path),
            color = Color.Red.copy(alpha = 0.5f),
            style = Stroke(width = 2f)
        )
    }
}

private fun Matrix.map(path: Path): Path {
    return Path().apply {
        path.forEach { segment ->
            when (segment) {
                is PathSegment.MoveTo -> moveTo(map(segment.point))
                is PathSegment.LineTo -> lineTo(map(segment.point))
                is PathSegment.QuadTo -> quadTo(map(segment.point1), map(segment.point2))
                is PathSegment.CurveTo -> curveTo(
                    map(segment.point1),
                    map(segment.point2),
                    map(segment.point3)
                )
                is PathSegment.Close -> close()
            }
        }
    }
}

private fun Matrix.map(point: Offset): Offset {
    val x = point.x - centerX
    val y = point.y - centerY
    val cosX = cos(rotationX)
    val sinX = sin(rotationX)
    val cosY = cos(rotationY)
    val sinY = sin(rotationY)
    
    val newX = x * cosY - y * sinX * sinY
    val newY = y * cosX
    
    return Offset(newX + centerX, newY + centerY)
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MaterialAnalysisCard.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.emfad.app.models.MaterialAnalysis
import com.emfad.app.models.MaterialType
import com.emfad.app.models.MaterialClassifier

@Composable
fun MaterialAnalysisCard(
    analysis: MaterialAnalysis?,
    classifier: MaterialClassifier = MaterialClassifier(),
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier
                .padding(16.dp)
                .fillMaxWidth(),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            Text(
                text = "Materialanalyse",
                style = MaterialTheme.typography.headlineSmall
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            analysis?.let {
                val (backgroundColor, textColor) = when (it.type) {
                    MaterialType.FERROUS_METAL -> Color(0xFFFFA500) to Color.White
                    MaterialType.NON_FERROUS_METAL -> Color(0xFF4CAF50) to Color.White
                    MaterialType.CAVITY -> Color(0xFF2196F3) to Color.White
                    MaterialType.UNKNOWN -> Color.Gray to Color.White
                }
                
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .background(backgroundColor)
                        .padding(16.dp),
                    contentAlignment = Alignment.Center
                ) {
                    Column(horizontalAlignment = Alignment.CenterHorizontally) {
                        Text(
                            text = when (it.type) {
                                MaterialType.FERROUS_METAL -> "Eisenhaltiges Metall"
                                MaterialType.NON_FERROUS_METAL -> "Nicht-eisenhaltiges Metall"
                                MaterialType.CAVITY -> "Hohlraum"
                                MaterialType.UNKNOWN -> "Unbekanntes Material"
                            },
                            color = textColor,
                            style = MaterialTheme.typography.headlineMedium
                        )
                        
                        Spacer(modifier = Modifier.height(8.dp))
                        
                        Text(
                            text = classifier.getMaterialDescription(it.type),
                            color = textColor,
                            style = MaterialTheme.typography.bodyLarge
                        )
                        
                        Spacer(modifier = Modifier.height(8.dp))
                        
                        Text(
                            text = "Zuverl√§ssigkeit: ${(it.confidence * 100).toInt()}%",
                            color = textColor,
                            style = MaterialTheme.typography.bodyLarge
                        )
                    }
                }
            } ?: Text(
                text = "Keine Analyse verf√ºgbar",
                style = MaterialTheme.typography.bodyLarge
            )
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MaterialCalibrationView.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.emfad.app.models.*
import java.util.Locale

@Composable
fun MaterialCalibrationView(
    calibration: MaterialCalibration,
    onAddCalibrationPoint: (CalibrationData) -> Unit,
    onRemoveCalibrationPoint: (CalibrationData) -> Unit,
    modifier: Modifier = Modifier
) {
    var selectedMaterialType by remember { mutableStateOf<MaterialType?>(null) }
    var depth by remember { mutableStateOf("") }
    var magneticField by remember { mutableStateOf("") }
    var electricField by remember { mutableStateOf("") }
    var frequency by remember { mutableStateOf("") }
    var abValue by remember { mutableStateOf("") }
    
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Materialkalibrierung",
                style = MaterialTheme.typography.headlineSmall
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Materialtyp-Auswahl
            MaterialTypeSelector(
                selectedType = selectedMaterialType,
                onTypeSelected = { selectedMaterialType = it }
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Eingabefelder
            OutlinedTextField(
                value = depth,
                onValueChange = { depth = it },
                label = { Text("Tiefe (mm)") },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            OutlinedTextField(
                value = magneticField,
                onValueChange = { magneticField = it },
                label = { Text("Magnetfeld (¬µT)") },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            OutlinedTextField(
                value = electricField,
                onValueChange = { electricField = it },
                label = { Text("Elektrisches Feld (V/m)") },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            OutlinedTextField(
                value = frequency,
                onValueChange = { frequency = it },
                label = { Text("Frequenz (Hz)") },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            OutlinedTextField(
                value = abValue,
                onValueChange = { abValue = it },
                label = { Text("A/B-Wert") },
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Kalibrierungspunkt hinzuf√ºgen
            Button(
                onClick = {
                    selectedMaterialType?.let { type ->
                        val calibrationData = CalibrationData(
                            materialType = type,
                            depth = depth.toFloatOrNull() ?: 0f,
                            magneticField = magneticField.toFloatOrNull() ?: 0f,
                            electricField = electricField.toFloatOrNull() ?: 0f,
                            frequency = frequency.toFloatOrNull() ?: 0f,
                            abValue = abValue.toFloatOrNull() ?: 0f
                        )
                        onAddCalibrationPoint(calibrationData)
                        
                        // Felder zur√ºcksetzen
                        depth = ""
                        magneticField = ""
                        electricField = ""
                        frequency = ""
                        abValue = ""
                    }
                },
                modifier = Modifier.fillMaxWidth(),
                enabled = selectedMaterialType != null
            ) {
                Text("Kalibrierungspunkt hinzuf√ºgen")
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Kalibrierungspunkte anzeigen
            Text(
                text = "Kalibrierungspunkte",
                style = MaterialTheme.typography.titleMedium
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            LazyColumn {
                items(MaterialType.values()) { materialType ->
                    CalibrationPointList(
                        materialType = materialType,
                        calibration = calibration,
                        onRemovePoint = onRemoveCalibrationPoint
                    )
                }
            }
        }
    }
}

@Composable
private fun MaterialTypeSelector(
    selectedType: MaterialType?,
    onTypeSelected: (MaterialType) -> Unit
) {
    Column {
        Text(
            text = "Materialtyp ausw√§hlen",
            style = MaterialTheme.typography.titleMedium
        )
        
        Spacer(modifier = Modifier.height(8.dp))
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            MaterialType.values().forEach { type ->
                FilterChip(
                    selected = type == selectedType,
                    onClick = { onTypeSelected(type) },
                    label = {
                        Text(
                            when (type) {
                                MaterialType.FERROUS_METAL -> "Eisenhaltig"
                                MaterialType.NON_FERROUS_METAL -> "Nicht-eisenhaltig"
                                MaterialType.CAVITY -> "Hohlraum"
                                else -> "Unbekannt"
                            }
                        )
                    }
                )
            }
        }
    }
}

@Composable
private fun CalibrationPointList(
    materialType: MaterialType,
    calibration: MaterialCalibration,
    onRemovePoint: (CalibrationData) -> Unit
) {
    val quality = calibration.getCalibrationQuality(materialType)
    
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp)
    ) {
        Column(
            modifier = Modifier.padding(8.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = when (materialType) {
                        MaterialType.FERROUS_METAL -> "Eisenhaltiges Metall"
                        MaterialType.NON_FERROUS_METAL -> "Nicht-eisenhaltiges Metall"
                        MaterialType.CAVITY -> "Hohlraum"
                        else -> "Unbekanntes Material"
                    },
                    style = MaterialTheme.typography.titleSmall
                )
                
                Text(
                    text = "Qualit√§t: ${(quality * 100).toInt()}%",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Kalibrierungsfaktoren anzeigen
            calibration.getCalibrationFactors(materialType)?.let { factors ->
                Text(
                    text = "Kalibrierungsfaktoren:",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = "Magnetisch: ${String.format(Locale.GERMAN, "%.2f", factors.magneticFactor)}",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = "Elektrisch: ${String.format(Locale.GERMAN, "%.2f", factors.electricFactor)}",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = "Tiefe: ${String.format(Locale.GERMAN, "%.2f", factors.depthFactor)}",
                    style = MaterialTheme.typography.bodyMedium
                )
                Text(
                    text = "Frequenz: ${String.format(Locale.GERMAN, "%.2f", factors.frequencyFactor)}",
                    style = MaterialTheme.typography.bodyMedium
                )
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MaterialPhysicsAnalysisCard.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.emfad.app.models.MaterialPhysicsAnalysis
import com.emfad.app.models.MaterialType
import com.emfad.app.models.LayerAnalysis

@Composable
fun MaterialPhysicsAnalysisCard(
    analysis: MaterialPhysicsAnalysis,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Physikalische Materialanalyse",
                style = MaterialTheme.typography.h6
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // 3D-Visualisierung
            Material3DVisualization(
                analysis = analysis,
                modifier = Modifier.fillMaxWidth()
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Materialtyp
            MaterialTypeRow(analysis.materialType)
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Tiefenanalyse
            AnalysisSection("Tiefenanalyse") {
                AnalysisRow(
                    label = "Gesch√§tzte Tiefe",
                    value = String.format("%.1f mm", analysis.depth)
                )
                AnalysisRow(
                    label = "Tiefen-Zuverl√§ssigkeit",
                    value = String.format("%.1f%%", analysis.depthConfidence * 100)
                )
                AnalysisRow(
                    label = "Skin-Tiefe",
                    value = String.format("%.1f mm", analysis.skinDepth)
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Grundlegende Messwerte
            AnalysisSection("Grundlegende Messwerte") {
                AnalysisRow(
                    label = "Gesch√§tzte Gr√∂√üe",
                    value = String.format("%.1f mm", analysis.size)
                )
                AnalysisRow(
                    label = "Leitf√§higkeit",
                    value = String.format("%.2e S/m", analysis.conductivity)
                )
                AnalysisRow(
                    label = "Magnetgradient",
                    value = String.format("%.1f nT/m", analysis.magneticGradient)
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Mengen- und Volumenanalyse
            AnalysisSection("Mengen- und Volumenanalyse") {
                analysis.massEstimate?.let { mass ->
                    AnalysisRow(
                        label = "Gesch√§tzte Masse",
                        value = String.format("%.1f kg", mass)
                    )
                }
                analysis.volumeEstimate?.let { volume ->
                    AnalysisRow(
                        label = "Gesch√§tztes Volumen",
                        value = String.format("%.3f m¬≥", volume)
                    )
                }
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Schichtanalyse
            if (analysis.layerAnalysis.isNotEmpty()) {
                AnalysisSection("Schichtanalyse") {
                    analysis.layerAnalysis.forEach { layer ->
                        LayerAnalysisRow(layer)
                    }
                }
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Gesamtzuverl√§ssigkeit
            AnalysisRow(
                label = "Gesamtzuverl√§ssigkeit",
                value = String.format("%.1f%%", analysis.confidence * 100)
            )
        }
    }
}

@Composable
private fun AnalysisSection(
    title: String,
    content: @Composable () -> Unit
) {
    Text(
        text = title,
        style = MaterialTheme.typography.subtitle1,
        modifier = Modifier.padding(vertical = 8.dp)
    )
    content()
}

@Composable
private fun LayerAnalysisRow(layer: LayerAnalysis) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        elevation = 2.dp
    ) {
        Column(
            modifier = Modifier.padding(8.dp)
        ) {
            Text(
                text = "${layer.material} (${layer.depth} mm)",
                style = MaterialTheme.typography.subtitle2
            )
            AnalysisRow(
                label = "Leitf√§higkeit",
                value = String.format("%.2e S/m", layer.conductivity)
            )
            AnalysisRow(
                label = "Magnetgradient",
                value = String.format("%.1f nT/m", layer.magneticGradient)
            )
            AnalysisRow(
                label = "Dielektrizit√§tskonstante",
                value = String.format("%.1f", layer.dielectricConstant)
            )
            AnalysisRow(
                label = "Dichte",
                value = String.format("%.1f g/cm¬≥", layer.density)
            )
        }
    }
}

@Composable
private fun MaterialTypeRow(type: MaterialType) {
    val (backgroundColor, textColor) = when (type) {
        MaterialType.FERROUS_METAL -> MaterialTheme.colors.primary to MaterialTheme.colors.onPrimary
        MaterialType.NON_FERROUS_METAL -> MaterialTheme.colors.secondary to MaterialTheme.colors.onSecondary
        MaterialType.CAVITY -> MaterialTheme.colors.error to MaterialTheme.colors.onError
        MaterialType.UNKNOWN -> MaterialTheme.colors.surface to MaterialTheme.colors.onSurface
    }
    
    Surface(
        color = backgroundColor,
        modifier = Modifier.fillMaxWidth()
    ) {
        Text(
            text = when (type) {
                MaterialType.FERROUS_METAL -> "Eisenhaltiges Metall"
                MaterialType.NON_FERROUS_METAL -> "Nicht-eisenhaltiges Metall"
                MaterialType.CAVITY -> "Hohlraum"
                MaterialType.UNKNOWN -> "Unbekanntes Material"
            },
            color = textColor,
            modifier = Modifier.padding(8.dp)
        )
    }
}

@Composable
private fun AnalysisRow(
    label: String,
    value: String
) {
    Row(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 4.dp),
        horizontalArrangement = Arrangement.SpaceBetween
    ) {
        Text(text = label)
        Text(
            text = value,
            style = MaterialTheme.typography.body1
        )
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MaterialThresholdSettings.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import com.emfad.app.models.MaterialClassifier

@Composable
fun MaterialThresholdSettings(
    classifier: MaterialClassifier,
    onThresholdsUpdated: () -> Unit,
    modifier: Modifier = Modifier
) {
    val thresholds = classifier.getCurrentThresholds()
    var ferrousMagnetic by remember { mutableStateOf(thresholds["Ferrous Magnetic"] ?: 80f) }
    var nonFerrousElectric by remember { mutableStateOf(thresholds["Non-Ferrous Electric"] ?: 30f) }
    var nonFerrousMagnetic by remember { mutableStateOf(thresholds["Non-Ferrous Magnetic"] ?: 20f) }

    Card(
        modifier = modifier
            .fillMaxWidth()
            .padding(16.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Materialklassifizierung - Schwellenwerte",
                style = MaterialTheme.typography.h6
            )
            
            Spacer(modifier = Modifier.height(16.dp))
            
            // Ferrous Magnetic Threshold
            Column {
                Text("Ferromagnetisch (¬µT): ${ferrousMagnetic.toInt()}")
                Slider(
                    value = ferrousMagnetic,
                    onValueChange = { ferrousMagnetic = it },
                    valueRange = 20f..200f,
                    steps = 18
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Non-Ferrous Electric Threshold
            Column {
                Text("Nicht-Ferromagnetisch E-Feld (V/m): ${nonFerrousElectric.toInt()}")
                Slider(
                    value = nonFerrousElectric,
                    onValueChange = { nonFerrousElectric = it },
                    valueRange = 10f..100f,
                    steps = 9
                )
            }
            
            Spacer(modifier = Modifier.height(8.dp))
            
            // Non-Ferrous Magnetic Threshold
            Column {
                Text("Nicht-Ferromagnetisch M-Feld (¬µT): ${nonFerrousMagnetic.toInt()}")
                Slider(
                    value = nonFerrousMagnetic,
                    onValueChange = { nonFerrousMagnetic = it },
                    valueRange = 5f..50f,
                    steps = 9
                )
            }
            
            Spacer(modifier = Modifier.height(16.dp))
            
            Button(
                onClick = {
                    classifier.updateThresholds(
                        ferrousMagnetic = ferrousMagnetic,
                        nonFerrousElectric = nonFerrousElectric,
                        nonFerrousMagnetic = nonFerrousMagnetic
                    )
                    onThresholdsUpdated()
                },
                modifier = Modifier.align(Alignment.End)
            ) {
                Text("Schwellenwerte speichern")
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MaterialTrendChart.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.material3.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp
import com.emfad.app.models.MaterialAnalysis
import com.emfad.app.models.MaterialType
import com.patrykandpatrick.vico.compose.axis.horizontal.bottomAxis
import com.patrykandpatrick.vico.compose.axis.vertical.startAxis
import com.patrykandpatrick.vico.compose.chart.Chart
import com.patrykandpatrick.vico.compose.chart.line.lineChart
import com.patrykandpatrick.vico.core.entry.entryModelOf

@Composable
fun MaterialTrendChart(
    analyses: List<MaterialAnalysis>,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .height(200.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Materialtrend",
                style = MaterialTheme.typography.headlineSmall
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Chart(
                chart = lineChart(),
                model = entryModelOf(analyses.map { 
                    when (it.type) {
                        MaterialType.METAL -> 1f
                        MaterialType.CAVITY -> 0f
                        MaterialType.UNKNOWN -> 0.5f
                    }
                }),
                startAxis = startAxis(),
                bottomAxis = bottomAxis(),
                modifier = Modifier
                    .fillMaxWidth()
                    .height(150.dp)
            )
            
            Spacer(modifier = Modifier.height(8.dp))
            
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                LegendItem("Metall", Color(0xFFFFA500))
                LegendItem("Hohlraum", Color(0xFF4CAF50))
                LegendItem("Unbekannt", Color.Gray)
            }
        }
    }
}

@Composable
private fun LegendItem(label: String, color: Color) {
    Row(
        verticalAlignment = androidx.compose.ui.Alignment.CenterVertically
    ) {
        Box(
            modifier = Modifier
                .size(12.dp)
                .background(color)
        )
        Spacer(modifier = Modifier.width(4.dp))
        Text(
            text = label,
            style = MaterialTheme.typography.bodySmall
        )
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/MeasurementPage.kt
# TYP: .kt
================================================================================
package com.emfad.app.views

import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.unit.dp
import androidx.lifecycle.viewmodel.compose.viewModel
import com.emfad.app.models.MeasurementSession
import com.emfad.app.viewmodels.MeasurementViewModel
import com.patrykandpatrick.vico.compose.axis.horizontal.bottomAxis
import com.patrykandpatrick.vico.compose.axis.vertical.startAxis
import com.patrykandpatrick.vico.compose.chart.Chart
import com.patrykandpatrick.vico.compose.chart.line.lineChart
import com.patrykandpatrick.vico.core.entry.entryModelOf

@Composable
fun MeasurementPage(
    viewModel: MeasurementViewModel = viewModel()
) {
    val uiState by viewModel.uiState.collectAsState()
    val currentSession by viewModel.currentSession.collectAsState()
    val measurements by viewModel.measurements.collectAsState()
    val statistics by viewModel.statistics.collectAsState()
    val materialAnalysis by viewModel.materialAnalysis.collectAsState()

    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp)
    ) {
        // Sitzungsstatus
        SessionStatusCard(currentSession)

        Spacer(modifier = Modifier.height(16.dp))

        // Materialanalyse
        MaterialAnalysisCard(materialAnalysis)

        Spacer(modifier = Modifier.height(16.dp))

        // Aktuelle Messwerte
        CurrentMeasurementCard(measurements.lastOrNull())

        Spacer(modifier = Modifier.height(16.dp))

        // Diagramm
        MeasurementChart(measurements)

        Spacer(modifier = Modifier.height(16.dp))

        // Statistiken
        StatisticsCard(statistics)

        Spacer(modifier = Modifier.height(16.dp))

        // Aktionsbuttons
        ActionButtons(
            uiState = uiState,
            onStartSession = { viewModel.startNewSession("EMFAD_UG12DS") },
            onEndSession = { viewModel.endCurrentSession() },
            onExport = { viewModel.exportCurrentSession() }
        )
    }
}

@Composable
private fun SessionStatusCard(session: MeasurementSession?) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Messsitzung: ${session?.let { "Aktiv" } ?: "Keine"}",
                style = MaterialTheme.typography.h6
            )
            session?.let {
                Text("Ort: ${it.location}")
                Text("Notizen: ${it.notes}")
                Text("Dauer: ${it.duration / 1000} Sekunden")
            }
        }
    }
}

@Composable
private fun CurrentMeasurementCard(measurement: EMFADMeasurement?) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Aktuelle Messung",
                style = MaterialTheme.typography.h6
            )
            measurement?.let {
                Text("E-Feld: ${it.electricField} V/m")
                Text("M-Feld: ${it.magneticField} ¬µT")
                Text("Frequenz: ${it.frequency} Hz")
                Text("Batterie: ${it.batteryLevel}%")
            }
        }
    }
}

@Composable
private fun MeasurementChart(measurements: List<EMFADMeasurement>) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .height(200.dp)
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Messverlauf",
                style = MaterialTheme.typography.h6
            )
            Chart(
                chart = lineChart(),
                model = entryModelOf(measurements.map { it.electricField.toFloat() }),
                startAxis = startAxis(),
                bottomAxis = bottomAxis(),
                modifier = Modifier
                    .fillMaxWidth()
                    .height(150.dp)
            )
        }
    }
}

@Composable
private fun StatisticsCard(statistics: Map<String, Double>) {
    Card(
        modifier = Modifier.fillMaxWidth()
    ) {
        Column(
            modifier = Modifier.padding(16.dp)
        ) {
            Text(
                text = "Statistiken",
                style = MaterialTheme.typography.h6
            )
            statistics.forEach { (key, value) ->
                Text("$key: $value")
            }
        }
    }
}

@Composable
private fun ActionButtons(
    uiState: MeasurementViewModel.MeasurementUiState,
    onStartSession: () -> Unit,
    onEndSession: () -> Unit,
    onExport: () -> Unit
) {
    Row(
        modifier = Modifier.fillMaxWidth(),
        horizontalArrangement = Arrangement.SpaceEvenly
    ) {
        when (uiState) {
            is MeasurementViewModel.MeasurementUiState.Initial,
            is MeasurementViewModel.MeasurementUiState.SessionEnded -> {
                Button(onClick = onStartSession) {
                    Text("Neue Messung starten")
                }
            }
            is MeasurementViewModel.MeasurementUiState.Measuring -> {
                Button(onClick = onEndSession) {
                    Text("Messung beenden")
                }
            }
            else -> {}
        }
        
        if (uiState is MeasurementViewModel.MeasurementUiState.SessionEnded) {
            Button(onClick = onExport) {
                Text("Exportieren")
            }
        }
    }
} 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/java/com/emfad/app/views/VisualizationPage.kt
# TYP: .kt
================================================================================
 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/drawable/ic_launcher_foreground.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<vector xmlns:android="http://schemas.android.com/apk/res/android"
    android:width="108dp"
    android:height="108dp"
    android:viewportWidth="108"
    android:viewportHeight="108">
    
    <!-- Hintergrundkreis -->
    <path
        android:fillColor="#FFFFFF"
        android:pathData="M54,54m-48,0a48,48 0,1 1,96 0a48,48 0,1 1,-96 0" />
    
    <!-- Wellenform -->
    <path
        android:fillColor="#2196F3"
        android:pathData="M54,30C40.19,30 29,41.19 29,55C29,68.81 40.19,80 54,80C67.81,80 79,68.81 79,55C79,41.19 67.81,30 54,30ZM54,74C43.51,74 35,65.49 35,55C35,44.51 43.51,36 54,36C64.49,36 73,44.51 73,55C73,65.49 64.49,74 54,74Z" />
    
    <!-- Zentralelektrode -->
    <path
        android:fillColor="#1976D2"
        android:pathData="M54,40C46.27,40 40,46.27 40,55C40,63.73 46.27,70 54,70C61.73,70 68,63.73 68,55C68,46.27 61.73,40 54,40ZM54,64C48.48,64 44,59.52 44,55C44,50.48 48.48,46 54,46C59.52,46 64,50.48 64,55C64,59.52 59.52,64 54,64Z" />
    
    <!-- Signalwellen -->
    <path
        android:fillColor="#BBDEFB"
        android:pathData="M54,50C51.79,50 50,51.79 50,55C50,58.21 51.79,60 54,60C56.21,60 58,58.21 58,55C58,51.79 56.21,50 54,50Z" />
</vector> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/mipmap-anydpi-v26/ic_launcher.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/mipmap-anydpi-v26/ic_launcher_round.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<adaptive-icon xmlns:android="http://schemas.android.com/apk/res/android">
    <background android:drawable="@color/ic_launcher_background"/>
    <foreground android:drawable="@drawable/ic_launcher_foreground"/>
</adaptive-icon> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/values-v27/themes.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.EMFADApp" parent="android:Theme.Material.Light.NoActionBar">
        <!-- Status- und Navigationsleiste -->
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/transparent</item>
        <item name="android:windowLightStatusBar">true</item>
        <item name="android:windowLightNavigationBar">true</item>
        
        <!-- Fenster-Eigenschaften -->
        <item name="android:windowBackground">@color/background</item>
        <item name="android:windowFullscreen">false</item>
        <item name="android:windowContentOverlay">@null</item>
        
        <!-- Material Design Attribute -->
        <item name="android:colorPrimary">@color/primary</item>
        <item name="android:colorPrimaryDark">@color/primary_dark</item>
        <item name="android:colorAccent">@color/accent</item>
        
        <!-- Text-Attribute -->
        <item name="android:textColorPrimary">@color/text_primary</item>
        <item name="android:textColorSecondary">@color/text_secondary</item>
        <item name="android:textColorHint">@color/text_hint</item>
    </style>
</resources> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/values/colors.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Prim√§rfarben -->
    <color name="primary">#2196F3</color>
    <color name="primary_dark">#1976D2</color>
    <color name="primary_light">#BBDEFB</color>
    <color name="accent">#FF4081</color>

    <!-- Materialfarben -->
    <color name="ferrous_metal">#FFA500</color>
    <color name="non_ferrous_metal">#4CAF50</color>
    <color name="cavity">#2196F3</color>
    <color name="unknown">#9E9E9E</color>

    <!-- Statusfarben -->
    <color name="success">#4CAF50</color>
    <color name="error">#F44336</color>
    <color name="warning">#FFC107</color>
    <color name="info">#2196F3</color>

    <!-- Textfarben -->
    <color name="text_primary">#212121</color>
    <color name="text_secondary">#757575</color>
    <color name="text_hint">#BDBDBD</color>

    <!-- Hintergrundfarben -->
    <color name="background">#FFFFFF</color>
    <color name="surface">#FFFFFF</color>
    <color name="divider">#BDBDBD</color>
</resources> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/values/dimens.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <!-- Abst√§nde -->
    <dimen name="spacing_xs">4dp</dimen>
    <dimen name="spacing_sm">8dp</dimen>
    <dimen name="spacing_md">16dp</dimen>
    <dimen name="spacing_lg">24dp</dimen>
    <dimen name="spacing_xl">32dp</dimen>

    <!-- Textgr√∂√üen -->
    <dimen name="text_xs">12sp</dimen>
    <dimen name="text_sm">14sp</dimen>
    <dimen name="text_md">16sp</dimen>
    <dimen name="text_lg">20sp</dimen>
    <dimen name="text_xl">24sp</dimen>
    <dimen name="text_xxl">32sp</dimen>

    <!-- Komponentengr√∂√üen -->
    <dimen name="button_height">48dp</dimen>
    <dimen name="input_height">56dp</dimen>
    <dimen name="icon_size">24dp</dimen>
    <dimen name="icon_size_lg">32dp</dimen>
    <dimen name="card_elevation">4dp</dimen>
    <dimen name="card_corner_radius">8dp</dimen>

    <!-- Chart-Dimensionen -->
    <dimen name="chart_height">200dp</dimen>
    <dimen name="chart_padding">16dp</dimen>
    <dimen name="chart_legend_height">24dp</dimen>
</resources> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/values/ic_launcher_background.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <color name="ic_launcher_background">#2196F3</color>
</resources> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/values/strings.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name">EMFAD Scanner</string>
    
    <!-- Fehlermeldungen -->
    <string name="error_measurement">Messfehler: %1$s</string>
    <string name="error_calibration">Kalibrierungsfehler: %1$s</string>
    <string name="error_analysis">Analysefehler: %1$s</string>
    <string name="error_calibration_point">Fehler beim Hinzuf√ºgen des Kalibrierungspunkts: %1$s</string>
</resources> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/values/themes.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <style name="Theme.EMFADApp" parent="android:Theme.Material.Light.NoActionBar">
        <item name="android:statusBarColor">@android:color/transparent</item>
        <item name="android:navigationBarColor">@android:color/transparent</item>
        <item name="android:windowLightStatusBar">true</item>
        <item name="android:windowBackground">@color/background</item>
        <item name="android:windowFullscreen">false</item>
        <item name="android:windowContentOverlay">@null</item>
        <item name="android:colorPrimary">@color/primary</item>
        <item name="android:colorPrimaryDark">@color/primary_dark</item>
        <item name="android:colorAccent">@color/accent</item>
        <item name="android:textColorPrimary">@color/text_primary</item>
        <item name="android:textColorSecondary">@color/text_secondary</item>
        <item name="android:textColorHint">@color/text_hint</item>
    </style>
</resources> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/xml/backup_rules.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<full-backup-content>
    <!-- Backup der Einstellungen -->
    <include domain="sharedpref" path="."/>
    
    <!-- Backup der Messdaten -->
    <include domain="database" path="."/>
    <include domain="file" path="."/>
    
    <!-- Kein Backup der tempor√§ren Dateien -->
    <exclude domain="file" path="temp/"/>
    <exclude domain="file" path="cache/"/>
</full-backup-content> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: app/src/main/res/xml/data_extraction_rules.xml
# TYP: .xml
================================================================================
<?xml version="1.0" encoding="utf-8"?>
<data-extraction-rules>
    <cloud-backup>
        <!-- Backup der Einstellungen -->
        <include domain="sharedpref" path="."/>
        
        <!-- Backup der Messdaten -->
        <include domain="database" path="."/>
        <include domain="file" path="."/>
        
        <!-- Kein Backup der tempor√§ren Dateien -->
        <exclude domain="file" path="temp/"/>
        <exclude domain="file" path="cache/"/>
    </cloud-backup>
    
    <device-transfer>
        <!-- √úbertragung der Einstellungen -->
        <include domain="sharedpref" path="."/>
        
        <!-- √úbertragung der Messdaten -->
        <include domain="database" path="."/>
        <include domain="file" path="."/>
        
        <!-- Keine √úbertragung der tempor√§ren Dateien -->
        <exclude domain="file" path="temp/"/>
        <exclude domain="file" path="cache/"/>
    </device-transfer>
</data-extraction-rules> 

======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: build.gradle
# TYP: .gradle
================================================================================
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id 'com.android.application' version '8.2.2' apply false
    id 'org.jetbrains.kotlin.android' version '1.9.22' apply false
}

// These settings are now handled in settings.gradle
/*
allprojects {
    repositories {
        google()
        mavenCentral()
    }
}
*/ 


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: codemagic.yaml
# TYP: .yaml
================================================================================
workflows:
  android-debug:
    name: Android Debug Build & Test
    instance_type: mac_mini_m1
    max_build_duration: 60
    environment:
      java: 17
      vars:
        PACKAGE_NAME: "com.emfad.app"
    cache:
      cache_paths:
        - ~/.gradle/caches
        - ~/.android/build-cache
    triggering:
      events:
        - push
        - pull_request
      branch_patterns:
        - pattern: develop
          include: true
          source: true
        - pattern: main
          include: true
          source: true
        - pattern: feature/*
          include: true
          source: true
    scripts:
      - name: Set up local properties
        script: |
          echo "sdk.dir=$ANDROID_SDK_ROOT" > "$CM_BUILD_DIR/local.properties"
      
      - name: Make gradlew executable
        script: |
          chmod +x gradlew
      
      - name: Build debug APK
        script: |
          ./gradlew assembleDebug --stacktrace --info --no-daemon
      
      - name: Run unit tests
        script: |
          ./gradlew testDebugUnitTest --continue --stacktrace
        test_report: app/build/test-results/testDebugUnitTest/TEST-*.xml
      
      - name: Run Android lint
        script: |
          ./gradlew lintDebug --stacktrace
        test_report: app/build/reports/lint-results-debug.xml
    
    artifacts:
      - app/build/outputs/**/*.apk
      - app/build/reports/lint-results-debug.html
      - app/build/test-results/**/*.xml
    
    publishing:
      email:
        recipients:
          - info@emfad.de
        notify:
          success: true
          failure: true

  android-release:
    name: Android Release Build
    instance_type: mac_mini_m1
    max_build_duration: 60
    environment:
      groups:
        - google_play
      vars:
        PACKAGE_NAME: "com.emfad.app"
        GOOGLE_PLAY_TRACK: internal
        # Auto-generate keystore environment variables
        CM_KEYSTORE_PATH: "$CM_BUILD_DIR/release.keystore"
        CM_KEYSTORE_PASSWORD: "emfad123"
        CM_KEY_ALIAS: "emfad_key"
        CM_KEY_PASSWORD: "emfad123"
      java: 17
    triggering:
      events:
        - tag
      tag_patterns:
        - pattern: v*.*.*
          include: true
    scripts:
      - name: Set up local properties
        script: |
          echo "sdk.dir=$ANDROID_SDK_ROOT" > "$CM_BUILD_DIR/local.properties"
      
      - name: Make gradlew executable
        script: |
          chmod +x gradlew
      
      - name: Generate release keystore
        script: |
          keytool -genkey -v \
            -keystore $CM_KEYSTORE_PATH \
            -keyalg RSA \
            -keysize 2048 \
            -validity 10000 \
            -alias $CM_KEY_ALIAS \
            -storepass $CM_KEYSTORE_PASSWORD \
            -keypass $CM_KEY_PASSWORD \
            -dname "CN=EMFAD, OU=Development, O=EMFAD GmbH, L=Bexley, ST=England, C=GB"
      
      - name: Build release APK
        script: |
          ./gradlew assembleRelease --stacktrace --info --no-daemon
      
      - name: Build Android App Bundle
        script: |
          ./gradlew bundleRelease --stacktrace --info --no-daemon
    
    artifacts:
      - app/build/outputs/**/*.apk
      - app/build/outputs/**/*.aab
      - app/build/outputs/**/mapping.txt
    
    publishing:
      email:
        recipients:
          - info@emfad.de
        notify:
          success: true
          failure: true
      google_play:
        credentials: $GCLOUD_SERVICE_ACCOUNT_CREDENTIALS
        track: $GOOGLE_PLAY_TRACK
        submit_as_draft: true


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: gradle.properties
# TYP: .properties
================================================================================
# Project-wide Gradle settings.
org.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8
org.gradle.parallel=true
org.gradle.caching=true

# Android settings
android.useAndroidX=true
android.enableJetifier=true

# Kotlin code style
kotlin.code.style=official

# Enable R8 full mode
android.enableR8.fullMode=true

# Disable unused features
android.defaults.buildfeatures.buildconfig=false
android.defaults.buildfeatures.aidl=false
android.defaults.buildfeatures.renderscript=false
android.defaults.buildfeatures.resvalues=false
android.defaults.buildfeatures.shaders=false


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: gradle/wrapper/gradle-wrapper.properties
# TYP: .properties
================================================================================
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-8.9-bin.zip
networkTimeout=10000
validateDistributionUrl=true
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: gradlew.bat
# TYP: .bat
================================================================================
@rem
@rem Copyright 2015 the original author or authors.
@rem
@rem Licensed under the Apache License, Version 2.0 (the "License");
@rem you may not use this file except in compliance with the License.
@rem You may obtain a copy of the License at
@rem
@rem      https://www.apache.org/licenses/LICENSE-2.0
@rem
@rem Unless required by applicable law or agreed to in writing, software
@rem distributed under the License is distributed on an "AS IS" BASIS,
@rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
@rem See the License for the specific language governing permissions and
@rem limitations under the License.
@rem
@rem SPDX-License-Identifier: Apache-2.0
@rem

@if "%DEBUG%"=="" @echo off
@rem ##########################################################################
@rem
@rem  Gradle startup script for Windows
@rem
@rem ##########################################################################

@rem Set local scope for the variables with windows NT shell
if "%OS%"=="Windows_NT" setlocal

set DIRNAME=%~dp0
if "%DIRNAME%"=="" set DIRNAME=.
@rem This is normally unused
set APP_BASE_NAME=%~n0
set APP_HOME=%DIRNAME%

@rem Resolve any "." and ".." in APP_HOME to make it shorter.
for %%i in ("%APP_HOME%") do set APP_HOME=%%~fi

@rem Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
set DEFAULT_JVM_OPTS="-Xmx64m" "-Xms64m"

@rem Find java.exe
if defined JAVA_HOME goto findJavaFromJavaHome

set JAVA_EXE=java.exe
%JAVA_EXE% -version >NUL 2>&1
if %ERRORLEVEL% equ 0 goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH. 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:findJavaFromJavaHome
set JAVA_HOME=%JAVA_HOME:"=%
set JAVA_EXE=%JAVA_HOME%/bin/java.exe

if exist "%JAVA_EXE%" goto execute

echo. 1>&2
echo ERROR: JAVA_HOME is set to an invalid directory: %JAVA_HOME% 1>&2
echo. 1>&2
echo Please set the JAVA_HOME variable in your environment to match the 1>&2
echo location of your Java installation. 1>&2

goto fail

:execute
@rem Setup the command line

set CLASSPATH=%APP_HOME%\gradle\wrapper\gradle-wrapper.jar


@rem Execute Gradle
"%JAVA_EXE%" %DEFAULT_JVM_OPTS% %JAVA_OPTS% %GRADLE_OPTS% "-Dorg.gradle.appname=%APP_BASE_NAME%" -classpath "%CLASSPATH%" org.gradle.wrapper.GradleWrapperMain %*

:end
@rem End local scope for the variables with windows NT shell
if %ERRORLEVEL% equ 0 goto mainEnd

:fail
rem Set variable GRADLE_EXIT_CONSOLE if you need the _script_ return code instead of
rem the _cmd.exe /c_ return code!
set EXIT_CODE=%ERRORLEVEL%
if %EXIT_CODE% equ 0 set EXIT_CODE=1
if not ""=="%GRADLE_EXIT_CONSOLE%" exit %EXIT_CODE%
exit /b %EXIT_CODE%

:mainEnd
if "%OS%"=="Windows_NT" endlocal

:omega


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: local.properties
# TYP: .properties
================================================================================
## This file must *NOT* be checked into Version Control Systems,
# as it contains information specific to your local configuration.
#
# Location of the SDK. This is only used by Gradle.
# For customization when using a Version Control System, please read the
# header note.
#Sun May 25 19:00:32 CEST 2025
sdk.dir=/Volumes/MEINE_SSD/AndroidSDK


======================================== ENDE DER DATEI ========================================


================================================================================
# DATEI: settings.gradle
# TYP: .gradle
================================================================================
pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
    }
}

rootProject.name = "emfad1"
include ':app'


======================================== ENDE DER DATEI ========================================

